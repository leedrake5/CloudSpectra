testr <- as.string(testr.a, quote=FALSE)#
#
spectral.map <- ggplot(fish.subset) +#
geom_tile(aes(x, y, colour=counts, fill=counts)) +#
scale_colour_gradientn(colours=testr) +#
scale_fill_gradientn(colours=testr) +#
coord_equal() +#
theme_classic()
?paste
testr <- paste(testr.a, collapse=TRUE)#
#
spectral.map <- ggplot(fish.subset) +#
geom_tile(aes(x, y, colour=counts, fill=counts)) +#
scale_colour_gradientn(colours=testr) +#
scale_fill_gradientn(colours=testr) +#
coord_equal() +#
theme_classic()
?Print
?print
testr <- print(testr.a, quote=FALSE)#
#
spectral.map <- ggplot(fish.subset) +#
geom_tile(aes(x, y, colour=counts, fill=counts)) +#
scale_colour_gradientn(colours=testr) +#
scale_fill_gradientn(colours=testr) +#
coord_equal() +#
theme_classic()
testr <- as.vector(testr.a)#
#
spectral.map <- ggplot(fish.subset) +#
geom_tile(aes(x, y, colour=counts, fill=counts)) +#
scale_colour_gradientn(colours=testr) +#
scale_fill_gradientn(colours=testr) +#
coord_equal() +#
theme_classic()
?as.object
?obj
?as.obj
testr
no.quote(testr)
noquote(testr)
print(testr)
print(testr[1])
paste(testr)
paste(tester, quotes=FALSE)
paste(testr, quotes=FALSE)
as.value(testr)
as.factor(testr)
as.factor(testr[1])
as.factor(testr[,1])
testr
object(testr)
??object
class(testr)
class(testr) <- value
is.object(testr)
as.object(testr)
get(testr)
testr.a <- "terrain.colors(10)"#
#
testr <- testr.a
testr
spectral.map <- ggplot(fish.subset) +#
geom_tile(aes(x, y, colour=counts, fill=counts)) +#
scale_colour_gradientn(colours=get(testr)) +#
scale_fill_gradientn(colours=get(testr)) +#
coord_equal() +#
theme_classic()
?get
?as.argument
?is.argument
testr.a <- get("terrain.colors(10)")#
#
testr <- testr.a
testr.a <- noquote("colours=terrain.colors(10)")
test.a
testr.a
testr <- testr.a#
#
spectral.map <- ggplot(fish.subset) +#
geom_tile(aes(x, y, colour=counts, fill=counts)) +#
scale_colour_gradientn(get(testr)) +#
scale_fill_gradientn(get(testr)) +#
coord_equal() +#
theme_classic()
testr
print(testr)
paste(testr)
get(testr)
return(testr)
testr.a <- noquote("colours=terrain.colors(10)")#
#
testr <- parse(testr.a)#
#
spectral.map <- ggplot(fish.subset) +#
geom_tile(aes(x, y, colour=counts, fill=counts)) +#
scale_colour_gradientn(get(testr)) +#
scale_fill_gradientn(get(testr)) +#
coord_equal() +#
theme_classic()
testr.a <- noquote("colours=terrain.colors(10)")#
#
testr <- testr.a#
#
spectral.map <- ggplot(fish.subset) +#
geom_tile(aes(x, y, colour=counts, fill=counts)) +#
scale_colour_gradientn(eval(testr)) +#
scale_fill_gradientn(eval(testr)) +#
coord_equal() +#
theme_classic()
spectral.map <- ggplot(fish.subset) +#
geom_tile(aes(x, y, colour=counts, fill=counts)) +#
scale_colour_gradientn(parse(testr)) +#
scale_fill_gradientn(parse(testr)) +#
coord_equal() +#
theme_classic()
spectral.map <- ggplot(fish.subset) +#
geom_tile(aes(x, y, colour=counts, fill=counts)) +#
scale_colour_gradientn(parse(text=testr)) +#
scale_fill_gradientn(parse(text=testr)) +#
coord_equal() +#
theme_classic()
spectral.map <- ggplot(fish.subset) +#
geom_tile(aes(x, y, colour=counts, fill=counts)) +#
scale_colour_gradientn(eval(parse(text=testr))) +#
scale_fill_gradientn(eval(parse(text=testr))) +#
coord_equal() +#
theme_classic()
spectral.map <- ggplot(fish.subset) +#
geom_tile(aes(x, y, colour=counts, fill=counts)) +#
scale_colour_gradientn(eval(parse(text=paste(testr)))) +#
scale_fill_gradientn(eval(parse(text=paste(testr)))) +#
coord_equal() +#
theme_classic()
spectral.map <- ggplot(fish.subset) +#
geom_tile(aes(x, y, colour=counts, fill=counts)) +#
scale_colour_gradientn(colours=eval(parse(text=paste(testr)))) +#
scale_fill_gradientn(colours=eval(parse(text=paste(testr)))) +#
coord_equal() +#
theme_classic()
spectral.map
testr.a <- noquote("terrain.colors(10)")#
#
testr <- testr.a#
#
spectral.map <- ggplot(fish.subset) +#
geom_tile(aes(x, y, colour=counts, fill=counts)) +#
scale_colour_gradientn(colours=eval(parse(text=paste(testr)))) +#
scale_fill_gradientn(colours=eval(parse(text=paste(testr)))) +#
coord_equal() +#
theme_classic()
spectral.map
runApp("~/Desktop/ArtaxMap App")
?textInput
runApp("~/Desktop/ArtaxMap App")
?selectInput
runApp("~/Desktop/ArtaxMap App")
?testInput
?textInput
runApp("~/Desktop/ArtaxMap App")
?textInput
?aes
runApp("~/Desktop/ArtaxMap App")
traceback()
runApp("~/Desktop/ArtaxMap App")
?stat_density2d
runApp("~/Desktop/ArtaxMap App")
library(rsconnect)
deployApp("~/Desktop/ArtaxMap App", appName="ArtaxMap")
library(shiny)
runApp("~/Desktop/ArtaxMap App")
#Erase everything that comes before#
rm(list = ls(all = TRUE))#
#
#Compatibility#
if(.Platform$OS.type=="windows") {#
    quartz<-function() windows()#
}#
###Load Packages#
library(TTR)#
library(ggplot2)#
library(gridExtra)#
library(scales)#
library(gtable)#
library(wq)#
library(Bchron)#
library(plyr)#
library(bcp)#
#library(mgcv)#
library(reshape2)#
library(pbapply)#
library(xlsx)#
library(data.table)#
library(dplyr)#
library(akima)#
library(ggmap)#
library(ggthemes)#
library(bcp)
####################################################
#######Calibration & Confidence Band Function#######
####################################################
####Function to organize plots in a window#
layOut = function(...) {#
    require(grid)#
    x <- list(...)#
    n <- max(sapply(x, function(x) max(x[[2]])))#
    p <- max(sapply(x, function(x) max(x[[3]])))#
    pushViewport(viewport(layout = grid.layout(n, p)))#
    for (i in seq_len(length(x))) {#
        print(x[[i]][[1]], vp = viewport(layout.pos.row = x[[i]][[2]],#
        layout.pos.col = x[[i]][[3]]))#
    }#
}#
#####Collapse Dates#
collapse.the.dates.begin <- function(sites, biogeo, general, dates, sigma) {#
    n.t <- rep(100, length(sites))#
    df <- data.frame(sites, biogeo, general, dates, sigma)#
    colnames(df) <- c("Site", "Biogeo_Uni", "St_Area_NE", "CYrBPunc", "Sigma")#
    df <- arrange(df, desc(CYrBPunc))#
    df <- arrange(df, desc(Site))#
    df <- arrange(df, desc(Biogeo_Uni))#
    df <- arrange(df, desc(St_Area_NE))#
    df$Ttest <- c(#
    (abs(df[1:(nrow(df)-1),4]-df[2:nrow(df), 4]))/((sqrt(df[2:nrow(df), 5]^2 + df[1:(nrow(df)-1),5]^2)*sqrt(1/100))), NA)#
    df$pvalue <- c((2*pt(df[1:nrow(df),6], 100, lower=FALSE)))#
    df$Collapse <- rep("No", length(sites))#
    df <- transform(df, Collapse = ifelse(pvalue > 0.05, "Yes", Collapse))#
    df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
    df <- as.data.frame(df)#
    df <- df[complete.cases(df),]#
    return(df)#
}#
#
collapse.the.dates.taxa <- function(sites, biogeo, general, dates, sigma, taxa) {#
    n.t <- rep(100, length(sites))#
    df <- data.frame(sites, biogeo, general, dates, sigma)#
    colnames(df) <- c("Site", "Biogeo_Uni", "St_Area_NE", "CYrBPunc", "Sigma", "Taxa")#
    df <- arrange(df, desc(CYrBPunc))#
    df <- arrange(df, desc(Site))#
    df <- arrange(df, desc(Biogeo_Uni))#
    df <- arrange(df, desc(St_Area_NE))#
    df$Ttest <- c(#
    (abs(df[1:(nrow(df)-1),4]-df[2:nrow(df), 4]))/((sqrt(df[2:nrow(df), 5]^2 + df[1:(nrow(df)-1),5]^2)*sqrt(1/100))), NA)#
    df$pvalue <- c((2*pt(df[1:nrow(df),6], 100, lower=FALSE)))#
    df$Collapse <- rep("No", length(sites))#
    df <- transform(df, Collapse = ifelse(pvalue > 0.05, "Yes", Collapse))#
    df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
    df <- as.data.frame(df)#
    df <- df[complete.cases(df),]#
    return(df)#
}#
####Function to organize plots in a window#
layOut = function(...) {#
    require(grid)#
    x <- list(...)#
    n <- max(sapply(x, function(x) max(x[[2]])))#
    p <- max(sapply(x, function(x) max(x[[3]])))#
    pushViewport(viewport(layout = grid.layout(n, p)))#
    for (i in seq_len(length(x))) {#
        print(x[[i]][[1]], vp = viewport(layout.pos.row = x[[i]][[2]],#
        layout.pos.col = x[[i]][[3]]))#
    }#
}#
#
####Function to maintain significant digits in plot#
fmt <- function(){#
    function(x) format(x,nsmall = 2,scientific = FALSE)#
}#
####################################################
#######Calibration & Confidence Band Function#######
####################################################
#
###Multicore apply function with status bar#
mcpblapply <- function (X, FUN, ..., mc.preschedule = TRUE, mc.set.seed = TRUE,#
mc.silent = FALSE, mc.cores = getOption("mc.cores", 2L),#
mc.cleanup = TRUE, mc.allow.recursive = TRUE, USE.NAMES = TRUE, simplify = TRUE)#
{#
    FUN <- match.fun(FUN)#
    if (!is.vector(X) || is.object(X))#
    X <- as.list(X)#
    B <- length(X)#
    if (!(interactive() && dopb() && B >= 1))#
    return(mclapply(X, FUN, ...#
    ))#
    pb <- startpb(0, B)#
    rval <- vector("list", B)#
    for (i in 1:B) {#
        rval[i] <- list(FUN(X[[i]], ...))#
        setpb(pb, i)#
    }#
    close(pb)#
    names(rval) <- names(X)#
    rval#
}#
#
mcpbsapply <- function (X, FUN, ..., mc.preschedule = TRUE, mc.set.seed = TRUE,#
mc.silent = FALSE, mc.cores = getOption("mc.cores", 2L),#
mc.cleanup = TRUE, mc.allow.recursive = TRUE, USE.NAMES = TRUE, simplify = TRUE)#
{#
    FUN <- match.fun(FUN)#
    answer <- mcpblapply(X = X, FUN = FUN,  ..., USE.NAMES = TRUE)#
    if (USE.NAMES && is.character(X) && is.null(names(answer)))#
    names(answer) <- X#
    if (!identical(simplify, FALSE) && length(answer))#
    simplify2array(answer, higher = (simplify == "array"))#
    else answer#
}#
#
mcreplicate <- function(n, expr, simplify = "array", mc.cores = getOption("mc.cores", 2L)) {#
    mcpbsapply(integer(n), eval.parent(substitute(function(...) expr)), mc.cores = getOption("mc.cores", 2L),#
    simplify = simplify)#
}#
conf.loess <- function(x, sigma, n, reps, xmin, xmax) {#
    samp.intcal <- rep("intcal13", length(x))#
    samp.slugdens <- BchronCalibrate(x, sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    res.by <- by(samp.ages$ageGrid, samp.ages$.id, median)#
    res.t <- t(res.by)#
    samp.age.grid <- c(samp.ages$ageGrid, xmin, xmax)#
    time <- seq(xmin+5, xmax-5, 10)#
    samp.grid <- sort(samp.age.grid, decreasing=TRUE)#
    samp.grid <- samp.grid[samp.grid < xmax & samp.grid > xmin]#
    samp.hist <- hist(samp.grid, breaks=length(time))#
    samp.hist <- data.frame(time, samp.hist$counts, samp.hist$counts/sum(samp.hist$counts))#
    colnames(samp.hist) <- c("Age", "Counts", "Density")#
    #samp.hist <- arrange(samp.all, desc(Age))#
    makeloess <- function(x, n){#
        time <- seq(xmin+5, xmax-5, 10)#
        samp.age <- sample(x, size=n, replace=TRUE)#
        samp.dist <- sapply(1:n, function(x) rnorm(500, samp.age, 85))#
        samp.dist <- as.vector(samp.dist)#
        samp.dist <- c(xmax, xmin, samp.dist)#
        samp.date <- tapply(samp.dist, cut(samp.dist, length(time)), length)#
        samp.loess <- lowess(time, samp.date, f=0.15)#
        samp.fitted <- samp.loess$y#
        return(samp.fitted)#
    }#
    samp.replicate <- (replicate(reps, makeloess(res.t, n)))#
    samp.replicate <- as.data.frame(samp.replicate)#
    samp.replicate[is.na(samp.replicate)] <- 0#
    samp.replicate <- sweep(samp.replicate,2,colSums(samp.replicate),`/`)#
    samp.results.replicate <- transform(samp.replicate, MEAN=apply(samp.replicate,1, mean, na.rm = TRUE))#
    samp.results.replicate <- transform(samp.results.replicate, SD=apply(samp.results.replicate,1, sd, na.rm = TRUE))#
    samp.descriptive <- data.frame(time, samp.results.replicate$MEAN, samp.results.replicate$SD)#
    colnames(samp.descriptive) <- c("Age", "Mean", "SD")#
    #samp.descriptive <- arrange(samp.descriptive, desc(Age))#
    samp.all <- data.frame(time, samp.hist$Density, samp.hist$Counts, samp.descriptive$Mean, samp.descriptive$SD, samp.replicate)#
    names(samp.all)[names(samp.all)=="time"] <- "Age"#
    names(samp.all)[names(samp.all)=="samp.descriptive.Mean"] <- "Mean"#
    names(samp.all)[names(samp.all)=="samp.descriptive.SD"] <- "SD"#
    names(samp.all)[names(samp.all)=="samp.hist.Density"] <- "Density"#
    names(samp.all)[names(samp.all)=="samp.hist.Counts"] <- "Counts"#
    samp.all <- arrange(samp.all, desc(Age))#
    return(samp.all)#
}#
taphonomic.correct <- function(stack.14C.data) {#
    df <- stack.14C.data#
    n.t <- 5.726442*(10^6)*(df$Age + 2176.4)^-1.3925309#
    lambda <- 1.3925309/(2176.4+df$Age)*100#
    lambda.r <- 1-lambda#
    n.t.relative <- n.t/128.8192#
    df$Counts.Corrected <-df$Counts/n.t.relative#
    count.mod.sum <- sum(df$Counts.Corrected)#
    df$Density.Corrected <- df$Counts.Corrected/count.mod.sum#
    return(df)#
}#
#
stack.14C.4D <- function(date, sigma, xmin, xmax, lat, long){#
    date <- c(date, 100)#
    sigma <- c(sigma, 50)#
    lat <- c(lat, 0)#
    long <- c(long, 0)#
    date.frame <- data.frame(date, sigma, lat, long)#
    names(date.frame) <- c("Date", "Sigma", "Lat", "Long")#
    date.frame <- date.frame[complete.cases(date.frame),]#
    date.sub <- subset(date.frame, (xmin-500) < Date & Date < (xmax + 500))#
    ids.cus = paste("date", 1:length(date.sub$Date), sep = "")#
    coord.sub <- data.frame(ids.cus, date.sub$Lat, date.sub$Long)#
    names(coord.sub) <- c(".id", "Lat", "Long")#
    samp.intcal <- rep("intcal13", length(date.sub$Date))#
    samp.slugdens <- BchronCalibrate(date.sub$Date, date.sub$Sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.mean <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, mean))#
    samp.sd <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, sd))#
    samp.frame <- data.frame(samp.mean, samp.sd)#
    colnames(samp.frame) <- c("Mean", "Sd")#
    samp.frame$Min <- samp.frame$Mean-date.sub$Sigma#
    samp.frame$Max <- samp.frame$Mean+date.sub$Sigma#
    samp.frame$Lat <- coord.sub$Lat#
    samp.frame$Long <- coord.sub$Long#
    samp.frame <- data.table(samp.frame)#
    lat.frame <- samp.frame[, list(Lat=Lat, ageGrid = seq(from=trunc(Min), to=trunc(Max))), by = 1:nrow(samp.frame)]#
    long.frame <- samp.frame[, list(Long=Long, ageGrid = seq(from=trunc(Min), to=trunc(Max))), by = 1:nrow(samp.frame)]#
    fin.frame <- data.frame(lat.frame$Lat, long.frame$Long, lat.frame$ageGrid)#
    colnames(fin.frame) <- c("Lat", "Long", "ageGrid")#
    return(fin.frame)#
}#
#######
stack.14C <- function(x, sigma, xmin, xmax, taxa){#
    samp.intcal <- rep("intcal13", length(x))#
    samp.slugdens <- BchronCalibrate(x, sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    fill <- seq(xmin, xmax, 1)#
    samp.age.grid <- c(samp.ages$ageGrid, fill)#
    samp.grid <- sort(samp.age.grid, decreasing=TRUE)#
    samp.grid <- samp.grid[samp.grid < xmax & samp.grid > xmin]#
    time <- seq(xmin+5, xmax-5, 10)#
    samp.hist <- hist(samp.grid, breaks=length(time))#
    samp.hist <- data.frame(time, samp.hist$counts, samp.hist$counts/sum(samp.hist$counts))#
    colnames(samp.hist) <- c("Age", "Counts", "Density")#
    corrected.samp.hist <- taphonomic.correct(samp.hist)#
    return(corrected.samp.hist)#
}#
stack.14C.taxa <- function(date, sigma, xmin, xmax, lat, long, taxa){#
    date <- as.numeric(as.vector(c(date, 49000)))#
    sigma <- as.numeric(as.vector(c(sigma, 4900)))#
    lat <- c(lat, 0)#
    long <- c(long, 0)#
    taxa <- as.vector(c(taxa, "blank"))#
    date.frame <- data.frame(date, sigma, lat, long, taxa)#
    names(date.frame) <- c("Date", "Sigma", "Lat", "Long", "Taxa")#
    date.frame <- date.frame[complete.cases(date.frame),]#
    date.sub <- subset(date.frame, (xmin) < Date & Date < (xmax))#
    ids.cus = paste("date", 1:length(date.sub$Date), sep = "")#
    coord.sub <- data.frame(ids.cus, date.sub$Lat, date.sub$Long, date.sub$Taxa)#
    names(coord.sub) <- c(".id", "Lat", "Long", "Taxa")#
    samp.intcal <- rep("intcal13", length(date.sub$Date))#
    samp.slugdens <- BchronCalibrate(date.sub$Date, date.sub$Sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.mean <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, mean))#
    samp.sd <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, sd))#
    samp.frame <- data.frame(samp.mean, samp.sd)#
    colnames(samp.frame) <- c("Mean", "Sd")#
    samp.frame$Min <- samp.frame$Mean-date.sub$Sigma#
    samp.frame$Max <- samp.frame$Mean+date.sub$Sigma#
    samp.frame$Lat <- coord.sub$Lat#
    samp.frame$Long <- coord.sub$Long#
    samp.frame$Taxa <- coord.sub$Taxa#
    samp.frame <- data.table(samp.frame)#
    lat.frame <- samp.frame[, list(Lat=Lat, ageGrid = seq(from=trunc(Min), to=trunc(Max))), by = 1:nrow(samp.frame)]#
    long.frame <- samp.frame[, list(Long=Long, ageGrid = seq(from=trunc(Min), to=trunc(Max))), by = 1:nrow(samp.frame)]#
    taxa.frame <- samp.frame[, list(Taxa=Taxa, ageGrid = seq(from=trunc(Min), to=trunc(Max))), by = 1:nrow(samp.frame)]#
    fin.frame <- data.frame(taxa.frame$Taxa, lat.frame$Lat, long.frame$Long, lat.frame$ageGrid)#
    colnames(fin.frame) <- c("Taxa", "Lat", "Long", "ageGrid")#
    return(fin.frame)#
}#
#
taxa.data <- function(stack.14C.taxa.object, taxa.names, xmin, xmax) {#
    temp.df.1 <- subset(stack.14C.taxa.object, stack.14C.taxa.object$Taxa==taxa.names)#
    temp.df <- data.frame(temp.df.1$ageGrid, factor(temp.df.1$Taxa))#
    colnames(temp.df) <- c("ageGrid", "Taxa")#
    temp.list <- split(temp.df$ageGrid, f=temp.df$Taxa)#
    temp.list <- rapply(temp.list, f=sort, how="list", decreasing=TRUE)#
    time <- seq(xmin+5, xmax-5, 10)#
    samp.hist.list <- rapply(temp.list, f=hist, how="list", breaks=length(time))#
    samp.mids <- sapply(samp.hist.list, "[[", 4)#
    samp.counts <- sapply(samp.hist.list, "[[", 2)#
    samp.density <- sapply(samp.hist.list, "[[", 3)#
    samp.mids.df <- ldply(samp.mids, data.frame)#
    samp.counts.df <- ldply(samp.counts, data.frame)#
    samp.density.df <- ldply(samp.density, data.frame)#
    samp.hist <- data.frame(samp.mids.df[1], samp.mids.df[2], samp.counts.df[2], samp.density.df[2])#
    colnames(samp.hist) <- c("Taxa", "Age", "Counts", "Density")#
    corrected.samp.hist <- taphonomic.correct(samp.hist)#
    return(corrected.samp.hist)#
}#
#
taxa.data.single <- function(stack.14C.taxa.object, taxa.names, xmin, xmax) {#
    temp.df.1 <- subset(stack.14C.taxa.object, stack.14C.taxa.object$Taxa==taxa.names)#
    temp.df <- data.frame(temp.df.1$ageGrid, factor(temp.df.1$Taxa))#
    colnames(temp.df) <- c("ageGrid", "Taxa")#
    temp.list <- split(temp.df$ageGrid, f=temp.df$Taxa)#
    temp.list <- rapply(temp.list, f=sort, how="list", decreasing=TRUE)#
    time <- seq(xmin+5, xmax-5, 10)#
    samp.hist.list <- rapply(temp.list, f=hist, how="list", breaks=length(time))#
    samp.mids <- sapply(samp.hist.list, "[[", 4)#
    samp.counts <- sapply(samp.hist.list, "[[", 2)#
    samp.density <- sapply(samp.hist.list, "[[", 3)#
    samp.mids.df <- ldply(samp.mids, data.frame)#
    samp.counts.df <- ldply(samp.counts, data.frame)#
    samp.density.df <- ldply(samp.density, data.frame)#
    samp.hist <- data.frame(samp.mids.df[1], samp.counts.df[1], samp.density.df[1])#
    colnames(samp.hist) <- c("Age", "Counts", "Density")#
    corrected.samp.hist <- taphonomic.correct(samp.hist)#
    return(corrected.samp.hist)#
}#
median.stack.14C <- function(x, sigma, xmin, xmax){#
    samp.intcal <- rep("intcal13", length(x))#
    samp.slugdens <- BchronCalibrate(x, sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.median <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, median))#
    medians.all <-as.vector(samp.median[,1])#
    n <- length(medians.all)#
    medians <- medians.all[medians.all < xmax & medians.all > xmin]#
    return(medians)#
}#
######Function to Generate Confidence Bands around SCDRD#
conf.cal.loess <- function(dates, sigma, n, reps, sites, xmin, xmax, ..., cores = getOption("mc.cores", 2L), collapse.dates=FALSE) {#
    collapse.the.dates <- function(sites, dates, sigma) {#
        n.t <- rep(100, length(sites))#
        df <- data.frame(sites, dates, sigma)#
        colnames(df) <- c("Sites", "Date", "Sigma")#
        df <- arrange(df, desc(Date))#
        df <- arrange(df, desc(Sites))#
        df$Ttest <- c(#
        (abs(df[1:(nrow(df)-1),2]-df[2:nrow(df), 2]))/((sqrt(df[2:nrow(df), 3]^2 + df[1:(nrow(df)-1),3]^2)*sqrt(1/100))), NA)#
        df$pvalue <- c((2*pt(df[1:nrow(df),4], 100, lower=FALSE)))#
        df$Collapse <- rep("No", length(sites))#
        df <- transform(df, Collapse = ifelse(pvalue > 0.05, "Yes", Collapse))#
        df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
        df <- as.data.frame(df)#
        df <- df[complete.cases(df),]#
        return(df)#
    }#
    uncollapse.the.dates <- function(sites, dates, sigma) {#
        df <- data.frame(sites, dates, sigma)#
        colnames(df) <- c("Sites", "Date", "Sigma")#
        return(df)#
    }#
    date.data <- if(isTRUE(collapse.dates)){#
        collapse.the.dates(sites, dates, sigma)#
    } else {#
        uncollapse.the.dates(sites, dates, sigma)#
    }#
    samp.intcal <- rep("intcal13", length(date.data$Date))#
    samp.slugdens <- BchronCalibrate(date.data$Date, date.data$Sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.mean <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, mean))#
    samp.sd <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, sd))#
    samp.frame <- data.frame(samp.mean, samp.sd, samp.ages$.id)#
    colnames(samp.frame) <- c("Mean", "Sd", "Id")#
    samp.frame$Min <- samp.frame$Mean-date.sub$Sigma*2#
    samp.frame$Max <- samp.frame$Mean+date.sub$Sigma*2#
    id.frame <- samp.frame[, list(Id=Id, ageGrid = seq(from=trunc(Min), to=trunc(Max))), by = 1:nrow(samp.frame)]#
    colnames(id.frame) <- c("Id", "ageGrid")#
    res.by <- by(samp.frame$ageGrid, samp.frame$.id, median)#
    res.t <- t(res.by)#
    fill <- seq(xmin, xmax, 1)#
    samp.age.grid <- c(samp.frame$ageGrid, fill)#
    time <- seq(xmin+5, xmax-5, 10)#
    samp.grid <- sort(samp.age.grid, decreasing=TRUE)#
    samp.grid <- samp.grid[samp.grid < xmax & samp.grid > xmin]#
    samp.hist <- hist(samp.grid, breaks=length(time))#
    samp.hist <- data.frame(time, samp.hist$counts, samp.hist$counts/sum(samp.hist$counts))#
    colnames(samp.hist) <- c("Age", "Counts", "Density")#
    #samp.hist <- arrange(samp.all, desc(Age))#
    makeloess <- function(dates, n){#
        time <- seq(xmin+5, xmax-5, 10)#
        n.s <- length(dates)#
        samp.order <- sample(n.s, size=n, replace=TRUE)#
        samp.dist.n <- samp.slugdens[samp.order]#
        temp.ages <- ldply(samp.dist.n, data.frame)#
        temp.age.grid <- c(temp.ages$ageGrid, fill)#
        temp.grid <- temp.age.grid[temp.age.grid < xmax & samp.grid > xmin]#
        samp.dist <- c(fill, temp.grid)#
        samp.dist <- as.vector(samp.dist)#
        samp.dist <- c(xmax, xmin, samp.dist)#
        samp.date <- tapply(samp.dist, cut(samp.dist, length(time)), length)#
        samp.loess <- lowess(time, samp.date, f=0.15)#
        samp.fitted <- samp.loess$y#
        return(samp.fitted)#
    }#
    samp.replicate <- (mcreplicate(reps, makeloess(dates, n)))#
    samp.replicate.dat <- as.data.frame(samp.replicate)#
    samp.replicate.dat[is.na(samp.replicate.dat)] <- 0#
    samp.replicated <- sweep(samp.replicate.dat,2,colSums(samp.replicate.dat),`/`)#
    samp.results.replicated.m <- transform(samp.replicated, MEAN=apply(X=samp.replicated, MARGIN=1, FUN=mean, na.rm = TRUE))#
    samp.results.replicated.s <- transform(samp.replicated, SD=apply(X=samp.replicated, MARGIN=1, FUN=sd, na.rm = TRUE))#
    samp.descriptive <- data.frame(time, samp.results.replicated.m$MEAN, samp.results.replicated.s$SD)#
    colnames(samp.descriptive) <- c("Age", "Mean", "SD")#
    #samp.descriptive <- arrange(samp.descriptive, desc(Age))#
    samp.all <- data.frame(time, samp.hist$Density, samp.hist$Counts, samp.descriptive$Mean, samp.descriptive$SD)#
    names(samp.all)[names(samp.all)=="time"] <- "Age"#
    names(samp.all)[names(samp.all)=="samp.descriptive.Mean"] <- "Mean"#
    names(samp.all)[names(samp.all)=="samp.descriptive.SD"] <- "SD"#
    names(samp.all)[names(samp.all)=="samp.hist.Density"] <- "Density"#
    names(samp.all)[names(samp.all)=="samp.hist.Counts"] <- "Counts"#
    samp.all <- arrange(samp.all, desc(Age))#
    return(samp.all)#
}#
######Function to Generate Confidence Bands around SCDRD#
conf.cal.loess.bad <- function(dates, sigma, n, reps, sites, xmin, xmax, ..., cores = getOption("mc.cores", 2L), collapse.dates=FALSE) {#
    collapse.the.dates <- function(sites, dates, sigma) {#
        n.t <- rep(100, length(sites))#
        df <- data.frame(sites, dates, sigma)#
        colnames(df) <- c("Sites", "Date", "Sigma")#
        df <- arrange(df, desc(Date))#
        df <- arrange(df, desc(Sites))#
        df$Ttest <- c(#
        (abs(df[1:(nrow(df)-1),2]-df[2:nrow(df), 2]))/((sqrt(df[2:nrow(df), 3]^2 + df[1:(nrow(df)-1),3]^2)*sqrt(1/100))), NA)#
        df$pvalue <- c((2*pt(df[1:nrow(df),4], 100, lower=FALSE)))#
        df$Collapse <- rep("No", length(sites))#
        df <- transform(df, Collapse = ifelse(pvalue > 0.05, "Yes", Collapse))#
        df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
        df <- as.data.frame(df)#
        df <- df[complete.cases(df),]#
        return(df)#
    }#
    uncollapse.the.dates <- function(sites, dates, sigma) {#
        df <- data.frame(sites, dates, sigma)#
        colnames(df) <- c("Sites", "Date", "Sigma")#
        return(df)#
    }#
    date.data <- if(isTRUE(collapse.dates)){#
        collapse.the.dates(sites, dates, sigma)#
    } else {#
        uncollapse.the.dates(sites, dates, sigma)#
    }#
    samp.intcal <- rep("intcal13", length(date.data$Date))#
    samp.slugdens <- BchronCalibrate(date.data$Date, date.data$Sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.mean <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, mean))#
    samp.sd <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, sd))#
    samp.frame <- data.frame(samp.mean, samp.sd, samp.ages$.id)#
    colnames(samp.frame) <- c("Mean", "Sd", "Id")#
    samp.frame$Min <- samp.frame$Mean-date.sub$Sigma*2#
    samp.frame$Max <- samp.frame$Mean+date.sub$Sigma*2#
    id.frame <- samp.frame[, list(Id=Id, ageGrid = seq(from=trunc(Min), to=trunc(Max))), by = 1:nrow(samp.frame)]#
    colnames(id.frame) <- c("Id", "ageGrid")#
    res.by <- by(samp.frame$ageGrid, samp.frame$.id, median)#
    res.t <- t(res.by)#
    fill <- seq(xmin, xmax, 1)#
    samp.age.grid <- c(samp.frame$ageGrid, fill)#
    time <- seq(xmin+5, xmax-5, 10)#
    samp.grid <- sort(samp.age.grid, decreasing=TRUE)#
    samp.grid <- samp.grid[samp.grid < xmax & samp.grid > xmin]#
    samp.hist <- hist(samp.grid, breaks=length(time))#
    samp.hist <- data.frame(time, samp.hist$counts, samp.hist$counts/sum(samp.hist$counts))#
    colnames(samp.hist) <- c("Age", "Counts", "Density")#
    #samp.hist <- arrange(samp.all, desc(Age))#
    makeloess <- function(dates, n){#
        time <- seq(xmin+5, xmax-5, 10)#
        n.s <- length(dates)#
        samp.order <- sample(n.s, size=n, replace=TRUE)#
        samp.dist.n <- samp.slugdens[samp.order]#
        temp.ages <- ldply(samp.dist.n, data.frame)#
        temp.age.grid <- c(temp.ages$ageGrid, fill)#
        temp.grid <- temp.age.grid[temp.age.grid < xmax & samp.grid > xmin]#
        samp.dist <- c(fill, temp.grid)#
        samp.dist <- as.vector(samp.dist)#
        samp.dist <- c(xmax, xmin, samp.dist)#
        samp.date <- tapply(samp.dist, cut(samp.dist, length(time)), length)#
        samp.loess <- lowess(time, samp.date, f=0.15)#
        samp.fitted <- samp.loess$y#
        return(samp.fitted)#
    }#
    samp.replicate <- (mcreplicate(reps, makeloess(dates, n)))#
    samp.replicate.dat <- as.data.frame(samp.replicate)#
    samp.replicate.dat[is.na(samp.replicate.dat)] <- 0#
    samp.replicated <- sweep(samp.replicate.dat,2,colSums(samp.replicate.dat),`/`)#
    samp.results.replicated.m <- transform(samp.replicated, MEAN=apply(X=samp.replicated, MARGIN=1, FUN=mean, na.rm = TRUE))#
    samp.results.replicated.s <- transform(samp.replicated, SD=apply(X=samp.replicated, MARGIN=1, FUN=sd, na.rm = TRUE))#
    samp.descriptive <- data.frame(time, samp.results.replicated.m$MEAN, samp.results.replicated.s$SD)#
    colnames(samp.descriptive) <- c("Age", "Mean", "SD")#
    #samp.descriptive <- arrange(samp.descriptive, desc(Age))#
    samp.all <- data.frame(time, samp.hist$Density, samp.hist$Counts, samp.descriptive$Mean, samp.descriptive$SD)#
    names(samp.all)[names(samp.all)=="time"] <- "Age"#
    names(samp.all)[names(samp.all)=="samp.descriptive.Mean"] <- "Mean"#
    names(samp.all)[names(samp.all)=="samp.descriptive.SD"] <- "SD"#
    names(samp.all)[names(samp.all)=="samp.hist.Density"] <- "Density"#
    names(samp.all)[names(samp.all)=="samp.hist.Counts"] <- "Counts"#
    samp.all <- arrange(samp.all, desc(Age))#
    return(samp.all)#
}#
#
###Traditional SCDPD#
BchronDensityCollapse <- function (dates, sigma, sites,  dfs = rep(100, length(dates)), numMix = 30,#
iterations = 10000, burn = 2000, thin = 8, updateAges = FALSE, collapse.dates=FALSE)#
{#
    collapse.the.dates <- function(sites, dates, sigma) {#
        n.t <- rep(100, length(sites))#
        df <- data.frame(sites, dates, sigma)#
        colnames(df) <- c("Sites", "Date", "Sigma")#
        df <- arrange(df, desc(Date))#
        df <- arrange(df, desc(Sites))#
        df$Ttest <- c(#
        (abs(df[1:(nrow(df)-1),2]-df[2:nrow(df), 2]))/((sqrt(df[2:nrow(df), 3]^2 + df[1:(nrow(df)-1),3]^2)*sqrt(1/100))), NA)#
        df$pvalue <- c((2*pt(df[1:nrow(df),4], 100, lower=FALSE)))#
        df$Collapse <- rep("No", length(sites))#
        df <- transform(df, Collapse = ifelse(pvalue > 0.05, "Yes", Collapse))#
        df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
        return(df)#
    }#
    uncollapse.the.dates <- function(sites, dates, sigma) {#
        df <- data.frame(sites, dates, sigma)#
        colnames(df) <- c("Sites", "Date", "Sigma")#
        return(df)#
    }#
    date.data <- if(isTRUE(collapse.dates)){#
        collapse.the.dates(sites, dates, sigma)#
    } else {#
        uncollapse.the.dates(sites, dates, sigma)#
    }#
    pathToCalCurves = system.file("data",#
    package = "Bchron")#
    calCurves <- rep("intcal13", length(date.data$Date))#
    ages <- date.data$Date#
    ageSds <- date.data$Sigma#
    if (length(ages) != length(ageSds))#
    stop("ages and 1-sigma errors must be same length")#
    if (length(ages) != length(calCurves))#
    stop("ages and Calibration curves must be same length")#
    x = BchronCalibrate(ages = ages, ageSds = ageSds, calCurves = calCurves,#
    pathToCalCurves = pathToCalCurves, eps = 0, dfs = rep(100,#
    length(ages)))#
    xSmall = BchronCalibrate(ages = ages, ageSds = ageSds, calCurves = calCurves,#
    pathToCalCurves = pathToCalCurves, dfs = rep(100, length(ages)))#
    n = length(x)#
    thetaRange = range(xSmall[[1]]$ageGrid)#
    for (i in 2:n) thetaRange = range(c(thetaRange, xSmall[[i]]$ageGrid))#
    offset = vector(length = n)#
    for (i in 1:n) {#
        offset[i] = ifelse(x[[i]]$calCurve == "normal", 61, 0)#
    }#
    gauss <- function(x, mu, sig) {#
        u <- (x - mu)/sig#
        y <- exp(-u * u/2)#
        y#
    }#
    gbase <- function(x, mus) {#
        sig <- (mus[2] - mus[1])/2#
        G <- outer(x, mus, gauss, sig)#
        G#
    }#
    clrInv = function(phi) {#
        return(exp(phi)/sum(exp(phi)))#
    }#
    J = numMix#
    mu = seq(thetaRange[1], thetaRange[2], length = numMix)#
    theta = vector(length = n)#
    for (j in 1:n) theta[j] = round(stats::rnorm(1, mean = x[[j]]$ageGrid[match(max(x[[j]]$densities),#
    x[[j]]$densities)], sd = ageSds[j]), 3)#
    phi = c(stats::runif(J - 1, -10, 10), 0)#
    p = as.numeric(clrInv(phi))#
    G = gbase(theta, mu)#
    remaining = (iterations - burn)/thin#
    thetaStore = matrix(ncol = length(theta), nrow = remaining)#
    pStore = matrix(ncol = J, nrow = remaining)#
    thetaAll = matrix(NA, ncol = n, nrow = iterations)#
    for (j in 1:n) thetaAll[, j] = sample(xSmall[[j]]$ageGrid,#
    size = iterations, prob = xSmall[[j]]$densities, replace = TRUE)#
    mu2 = mu#
    sigma2 = (mu[2] - mu[1])/2#
    my_dnorm = function(x) stats::dnorm(x, mean = mu2, sd = sigma2)#
    pb = utils::txtProgressBar(min = 1, max = iterations, style = 3,#
    width = 60, title = "Running BchronDensity")#
    for (i in 1:iterations) {#
        utils::setTxtProgressBar(pb, i)#
        if (i > burn & i%%thin == 0) {#
            ind = (i - burn)/thin#
            thetaStore[ind, ] = theta#
            pStore[ind, ] = p#
        }#
        if (updateAges) {#
            for (j in 1:n) {#
                thetaNew = round(stats::rnorm(1, theta[j], 0.5),#
                3)#
                thetaNewMatch = as.integer(thetaNew + offset[j]) +#
                1#
                thetaNewLogDens = max(log(x[[j]]$densities[thetaNewMatch]),#
                -1e+06)#
                priorNew.dens = sum(p * stats::dnorm(thetaNew,#
                mean = mu2, sd = sigma2))#
                thetaMatch = as.integer(theta[j] + offset[j]) +#
                1#
                thetaLogDens = max(log(x[[j]]$densities[thetaMatch]),#
                -1e+06)#
                priorDens = sum(p * stats::dnorm(theta[j], mean = mu2,#
                sd = sigma2))#
                logRtheta = thetaNewLogDens - thetaLogDens +#
                log(priorNew.dens) - log(priorDens)#
                if (stats::runif(1) < exp(logRtheta))#
                theta[j] = thetaNew#
            }#
        }#
        else {#
            theta = thetaAll[i, ]#
        }#
        for (j in 1:(J - 1)) {#
            phiNew = stats::rnorm(1, phi[j], 1)#
            phiAllNew = phi#
            phiAllNew[j] = phiNew#
            pNew = as.numeric(clrInv(phiAllNew))#
            phiNewLogDens = sum(log(G %*% pNew))#
            phiLogDens = sum(log(G %*% p))#
            logRphi = phiNewLogDens - phiLogDens + stats::dunif(phiNew,#
            -10, 10, log = TRUE) - stats::dunif(phi[j], -10,#
            10, log = TRUE)#
            if (stats::runif(1) < exp(logRphi)) {#
                phi[j] = phiNew#
                p = as.numeric(clrInv(phi))#
            }#
        }#
    }#
    output = list(theta = thetaStore, p = pStore, mu = mu, calAges = xSmall,#
    G = G)#
    class(output) = "BchronDensityRun"#
    return(output)#
}#
#
###Function to modify existing SCDPD from BchronDensity (modified from Bchron)#
SlugDens.t <- function (x, xmin, xmax)#
{#
    n = length(x$calAges)#
    thetaRange = range(x$calAges[[1]]$ageGrid)#
    for (i in 2:n) thetaRange = range(c(thetaRange, x$calAges[[i]]$ageGrid))#
    dateGrid = seq(xmin, xmax, length = 1000)#
    gauss <- function(x, mu, sig) {#
        u <- (x - mu)/sig#
        y <- exp(-u * u/2)#
        y#
    }#
    gbase <- function(x, mus) {#
        sig <- (mus[2] - mus[1])/2#
        G <- outer(x, mus, gauss, sig)#
        G#
    }#
    Gstar = gbase(dateGrid, x$mu)#
    dens = vector(length = length(dateGrid))#
    for (i in 1:nrow(x$p)) {#
        dens = dens + Gstar %*% x$p[i, ]#
    }#
    densFinal = dens/sum(dens)#
    slugbase <- data.frame(dateGrid,densFinal)#
    colnames(slugbase) <- c("Age", "Density")#
    slugbase <- arrange(slugbase, desc(Age))#
    return(slugbase)#
}#
#
SlugSig <- function(x, sigma, n, reps, xmin, xmax) {#
    time <- seq(xmin+5, xmax-5, 10)#
    samp.intcal <- rep("intcal13", length(x))#
    samp.slugdens <- BchronDensity(x, sigma, samp.intcal, numMix = 30, iterations=10000, burn=2000, thin=8, updateAges=FALSE)#
    samp.hist <- SlugDens.t(samp.slugdens, xmin, xmax)#
    makeloess <- function(x, n){#
        time <- seq(xmin+5, xmax-5, 10)#
        samp.14C <- sample(x, size=n, replace=TRUE)#
        samp.sig <- sample(sigma, size=n, replace=TRUE)#
        samp.dist.n <- BchronDensity(samp.14C, samp.sig, rep("intcal13", n), numMix = 30, iterations=10000, burn=2000, thin=8, updateAges=FALSE)#
        samp.dist <- SlugDens.t(samp.dist.n, xmin, xmax)#
        samp.loess <- lowess(samp.dist$Age, samp.dist$Density, f=0.15)#
        samp.fitted <- samp.loess$y#
        return(samp.fitted)#
    }#
    samp.replicate <- (pbreplicate(reps, makeloess(x, n)))#
    samp.replicate <- as.data.frame(samp.replicate)#
    samp.replicate[is.na(samp.replicate)] <- 0#
    samp.replicate <- sweep(samp.replicate,2,colSums(samp.replicate),`/`)#
    samp.results.replicate <- transform(samp.replicate, MEAN=apply(samp.replicate,1, mean, na.rm = TRUE))#
    samp.results.replicate <- transform(samp.results.replicate, SD=apply(samp.results.replicate,1, sd, na.rm = TRUE))#
    samp.descriptive <- data.frame(samp.hist$Age, samp.results.replicate$MEAN, samp.results.replicate$SD)#
    colnames(samp.descriptive) <- c("Age", "Mean", "SD")#
    #samp.descriptive <- arrange(samp.descriptive, desc(Age))#
    samp.all <- data.frame(samp.hist$Age, samp.hist$Density, samp.descriptive$Mean, samp.descriptive$SD, samp.replicate)#
    names(samp.all)[names(samp.all)=="samp.hist.Age"] <- "Age"#
    names(samp.all)[names(samp.all)=="samp.descriptive.Mean"] <- "Mean"#
    names(samp.all)[names(samp.all)=="samp.descriptive.SD"] <- "SD"#
    names(samp.all)[names(samp.all)=="samp.hist.Density"] <- "Density"#
    samp.all <- arrange(samp.all, desc(Age))#
    return(samp.all)#
}#
####Function to maintain significant digits in plot#
fmt <- function(){#
    function(x) format(x,nsmall = 4,scientific = FALSE)#
}#
collapse.the.dates.begin <- function(sites, region, taxa, dates, sigma, lat, long, datemin, datemax) {#
    n.t <- rep(100, length(sites))#
    df.1 <- data.frame(sites, region, dates, sigma, lat, long)#
    colnames(df.1) <- c("Site", "Region", "X14C.year", "Sigma", "Lat", "Long")#
    df <- subset(df.1, df.1$X14C.year < datemax & df.1$X14C.year > datemin)#
    df <- arrange(df, desc(X14C.year))#
    df <- arrange(df, desc(Site))#
    df <- arrange(df, desc(Region))#
    df$Ttest <- c(#
    (abs(df[1:(nrow(df)-1),3]-df[2:nrow(df), 3]))/((sqrt(df[2:nrow(df), 4]^2 + df[1:(nrow(df)-1),4]^2)*sqrt(1/100))), NA)#
    df$pvalue <- c((2*pt(df[1:nrow(df),7], 100, lower=FALSE)))#
    df$Collapse <- rep("No", length(df$Site))#
    df <- transform(df, Collapse = ifelse(pvalue > 0.05, "Yes", Collapse))#
    df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
    df <- as.data.frame(df)#
    df <- df[complete.cases(df),]#
    return(df)#
}#
collapse.the.dates.taxa <- function(sites, region, taxa, dates, sigma, lat, long, datemin, datemax) {#
    n.t <- rep(100, length(sites))#
    df.1 <- data.frame(sites, region, dates, sigma, lat, long, taxa)#
    colnames(df.1) <- c("Site", "Region", "X14C.year", "Sigma", "Lat", "Long", "Taxa")#
    df <- subset(df.1, df.1$X14C.year < datemax & df.1$X14C.year > datemin)#
    df <- arrange(df, desc(X14C.year))#
    df <- arrange(df, desc(Site))#
    df <- arrange(df, desc(Region))#
    df$Ttest <- c(#
    (abs(df[1:(nrow(df)-1),3]-df[2:nrow(df), 3]))/((sqrt(df[2:nrow(df), 4]^2 + df[1:(nrow(df)-1),4]^2)*sqrt(1/100))), NA)#
    df$pvalue <- c((2*pt(df[1:nrow(df),8], 100, lower=FALSE)))#
    df$Collapse <- rep("No", length(df$Site))#
    df <- transform(df, Collapse = ifelse(pvalue > 0.05, "Yes", Collapse))#
    df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
    df <- as.data.frame(df)#
    df <- df[complete.cases(df),]#
    return(df)#
}#
#
site.median <- function(sites, region, dates, sigma) {#
    n.t <- rep(100, length(sites))#
    df <- data.frame(sites, region, dates, sigma)#
    colnames(df) <- c("Site", "Region", "X14C.year", "Sigma")#
    df <- arrange(df, desc(X14C.year))#
    df <- arrange(df, desc(Region))#
    df <- arrange(df, desc(Site))#
    df$Collapse <- rep("No", length(sites))#
    df <- transform(df, Collapse = ifelse(df[nrow(df)] > 0.05, "Yes", Collapse))#
    df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
    df <- as.data.frame(df)#
    df <- df[complete.cases(df),]#
    return(df)#
}#
site.time <- function(sites, dates, sigma, xmin, xmax, time) {#
    df <- data.frame(sites, dates, sigma)#
    colnames(df) <- c("Site",  "X14C.year", "Sigma")#
    df <- arrange(df, desc(X14C.year))#
    df <- arrange(df, desc(Site))#
    site.frame <- aggregate(x=df$X14C.year, by=list(df$Site), FUN=mean)#
    site.vector <- site.frame$x#
    site.frame.sig <- aggregate(x=df$Sigma, by=list(df$Site), FUN=mean)#
    site.vector.sig <- site.frame.sig$x#
    samp.intcal <- rep("intcal13", length(site.vector))#
    samp.slugdens <- BchronCalibrate(site.vector, site.vector.sig, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.median <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, median))#
    medians.all <-as.vector(samp.median[,1])#
    medians <- medians.all[medians.all < xmax & medians.all > xmin]#
    median.simple <- round((medians/100000), digits=2)*100000#
    median.table <- table(median.simple)#
    median.values <- as.numeric(paste(median.table))#
    median.frame <- data.frame(t(median.values))#
    colnames(median.frame) <- names(median.table)#
    median.t <- data.frame(t(median.frame))#
    median.df <- data.frame(add_rownames(median.t, "VALUE"))#
    colnames(median.df) <- c("Millenium", "Site")#
    median.df <- median.df[with(median.df, order(as.numeric(Millenium))), ]#
    null <- rep(0, length(time))#
    null.frame <- t(data.frame(null))#
    colnames(null.frame) <- time#
    null.t <- data.frame(t(null.frame))#
    null.df <- data.frame(add_rownames(null.t, "VALUE"))#
    colnames(null.df) <- c("Millenium", "Site")#
    all.frame <- merge(null.df, median.df, all=TRUE, by="Millenium")#
    all.frame[is.na(all.frame)] <- 0#
    all.frame <- all.frame[with(all.frame, order(as.numeric(Millenium))), ]#
    the.result <- data.frame(all.frame$Millenium, all.frame$Site.y)#
    colnames(the.result) <- c("Millenium", "Sites")#
    scaled <- as.vector(apply(data.frame(the.result$Sites), 2, function(x) scale(x)))#
    scaled.mean <- mean(scaled)#
    scaled.sd <- sd(scaled)#
    the.result$z.score <- (scaled-scaled.mean)/scaled.sd#
    the.result$p.value <- pnorm(the.result$z.score, lower.tail=FALSE)#
    return(format(the.result, digits=2))#
}#
median.stack.14C <- function(dates, sigma, sites, xmin, xmax, time){#
    samp.intcal <- rep("intcal13", length(dates))#
    samp.slugdens <- BchronCalibrate(dates, sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.median <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, median))#
    medians.all <-as.vector(samp.median[,1])#
    medians <- medians.all[medians.all < xmax & medians.all > xmin]#
    median.simple <- round((medians/100000), digits=2)*100000#
    median.table <- table(median.simple)#
    median.values <- as.numeric(paste(median.table))#
    median.frame <- data.frame(t(median.values))#
    colnames(median.frame) <- names(median.table)#
    median.t <- data.frame(t(median.frame))#
    median.df <- data.frame(add_rownames(median.t, "VALUE"))#
    colnames(median.df) <- c("Millenium", "Site")#
    median.df <- median.df[with(median.df, order(as.numeric(Millenium))), ]#
    null <- rep(0, length(time))#
    null.frame <- t(data.frame(null))#
    colnames(null.frame) <- time#
    null.t <- data.frame(t(null.frame))#
    null.df <- data.frame(add_rownames(null.t, "VALUE"))#
    colnames(null.df) <- c("Millenium", "Site")#
    all.frame <- merge(null.df, median.df, all=TRUE, by="Millenium")#
    all.frame[is.na(all.frame)] <- 0#
    all.frame <- all.frame[with(all.frame, order(as.numeric(Millenium))), ]#
    the.result <- data.frame(all.frame$Millenium, all.frame$Site.y)#
    colnames(the.result) <- c("Millenium", "Sites")#
    scaled <- as.vector(apply(data.frame(the.result$Sites), 2, function(x) scale(x)))#
    scaled.mean <- mean(scaled)#
    scaled.sd <- sd(scaled)#
    the.result$z.score <- (scaled-scaled.mean)/scaled.sd#
    the.result$p.value <- pnorm(the.result$z.score, lower.tail=FALSE)#
    return(format(the.result, digits=2))#
}#
site.time.half <- function(sites, dates, sigma, xmin, xmax, time) {#
    df <- data.frame(sites, dates, sigma)#
    colnames(df) <- c("Site",  "X14C.year", "Sigma")#
    df <- arrange(df, desc(X14C.year))#
    df <- arrange(df, desc(Site))#
    site.frame <- aggregate(x=df$X14C.year, by=list(df$Site), FUN=mean)#
    site.vector <- site.frame$x#
    site.frame.sig <- aggregate(x=df$Sigma, by=list(df$Site), FUN=mean)#
    site.vector.sig <- site.frame.sig$x#
    samp.intcal <- rep("intcal13", length(site.vector))#
    samp.slugdens <- BchronCalibrate(site.vector, site.vector.sig, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.median <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, median))#
    medians.all <-as.vector(samp.median[,1])#
    medians <- medians.all[medians.all < xmax & medians.all > xmin]#
    return(medians)#
}#
median.stack.14C.half <- function(x, sigma, sites, xmin, xmax){#
    samp.intcal <- rep("intcal13", length(x))#
    samp.slugdens <- BchronCalibrate(x, sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.median <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, median))#
    medians.all <-as.vector(samp.median[,1])#
    medians <- medians.all[medians.all < xmax & medians.all > xmin]#
    return(medians)#
}
gisp2 <- read.csv(file="/Users/lee/Dropbox/Documents/GISP and Civilization/gisp2.csv")
head(gisp2)
roman.gisp2 <- ggplot(gisp2) +#
geom_line(aes(1950-Age, Temperature..C.))+#
geom_text(aes(x=40, y=1.8, label="Pax Romana"))+#
geom_text(aes(x=270, y=2.3, label="Imperial Crisis"))+#
geom_rect(aes(NULL, NULL), xmin=-113, xmax=-101, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=-106, y=-1.4, label="Cimbrian War"))+#
geom_rect(aes(NULL, NULL), xmin=166, xmax=180, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=175, y=-1.4, label="Marcomannic War"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=376, y=-1.4, label="Visigothic War"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=550, y=-1.4, label="Migration Period"))+#
geom_line(aes(1950-Age, Temperature..C.), lwd=1.1)+#
geom_line(aes(1950-Age, Temperature..C.), colour="light blue", lwd=0.5) +#
scale_x_continuous("Year BC/AD", limits = c(-500, 750)) +#
scale_y_continuous("Temperature (C)") +#
theme_light()#
roman.gisp2
roman.gisp2 <- ggplot(gisp2) +#
geom_line(aes(1950-Age, Temperature..C.))+#
geom_text(aes(x=40, y=1.8, label="Pax Romana"))+#
geom_text(aes(x=270, y=2.3, label="Imperial Crisis"))+#
geom_rect(aes(NULL, NULL), xmin=-113, xmax=-101, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=-106, y=-1.4, label="Cimbrian War"))+#
geom_rect(aes(NULL, NULL), xmin=166, xmax=180, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=175, y=-1.4, label="Marcomannic War"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=376, y=-1.4, label="Visigothic War"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=550, y=-1.4, label="Migration Period"))+#
geom_line(aes(1950-Age, Temperature..C.), lwd=1.1)+#
geom_line(aes(1950-Age, Temperature..C.), colour="light blue", lwd=0.5) +#
scale_x_continuous("Year BC/AD", limits = c(-500, 750)) +#
scale_y_continuous("Temperature (C)", limits = c(-35, -28)) +#
theme_light()#
roman.gisp2
roman.gisp2 <- ggplot(gisp2) +#
geom_line(aes(1950-Age, Temperature..C.))+#
geom_text(aes(x=40, y=1.8, label="Pax Romana"))+#
geom_text(aes(x=270, y=2.3, label="Imperial Crisis"))+#
geom_rect(aes(NULL, NULL), xmin=-113, xmax=-101, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=-106, y=-1.4, label="Cimbrian War"))+#
geom_rect(aes(NULL, NULL), xmin=166, xmax=180, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=175, y=-1.4, label="Marcomannic War"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=376, y=-1.4, label="Visigothic War"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=550, y=-1.4, label="Migration Period"))+#
geom_line(aes(1950-Age, Temperature..C.), lwd=1.1)+#
geom_line(aes(1950-Age, Temperature..C.), colour="light blue", lwd=0.5) +#
scale_x_continuous("Year BC/AD", limits = c(-500, 750)) +#
scale_y_continuous("Temperature (C)", limits = c(-33, -29)) +#
theme_light()#
roman.gisp2
roman.gisp2 <- ggplot(gisp2) +#
geom_line(aes(1950-Age, Temperature..C.))+#
geom_text(aes(x=40, y=1.8, label="Pax Romana"))+#
geom_text(aes(x=270, y=2.3, label="Imperial Crisis"))+#
geom_rect(aes(NULL, NULL), xmin=-113, xmax=-101, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=-106, y=-1.4, label="Cimbrian War"))+#
geom_rect(aes(NULL, NULL), xmin=166, xmax=180, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=175, y=-1.4, label="Marcomannic War"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=376, y=-1.4, label="Visigothic War"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=550, y=-1.4, label="Migration Period"))+#
geom_line(aes(1950-Age, Temperature..C.), lwd=1.1)+#
geom_line(aes(1950-Age, Temperature..C.), colour="light blue", lwd=0.5) +#
scale_x_continuous("Year BC/AD", limits = c(-400, 800)) +#
scale_y_continuous("Temperature (C)", limits = c(-33, -29)) +#
theme_light()#
roman.gisp2
roman.gisp2 <- ggplot(gisp2) +#
geom_line(aes(1950-Age, Temperature..C.))+#
geom_text(aes(x=40, y=1.8, label="Pax Romana"))+#
geom_text(aes(x=270, y=2.3, label="Imperial Crisis"))+#
geom_rect(aes(NULL, NULL), xmin=-113, xmax=-101, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=-106, y=-1.4, label="Cimbrian War"))+#
geom_rect(aes(NULL, NULL), xmin=166, xmax=180, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=175, y=-1.4, label="Marcomannic War"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=376, y=-1.4, label="Visigothic War"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=550, y=-1.4, label="Migration Period"))+#
geom_line(aes(1950-Age, Temperature..C.), lwd=1.1)+#
geom_line(aes(1950-Age, Temperature..C.), colour="light blue", lwd=0.5) +#
scale_x_continuous("Year BC/AD", limits = c(-400, 800)) +#
scale_y_continuous("Temperature (C)", limits = c(-32.5, -28.5)) +#
theme_light()#
roman.gisp2
roman.gisp2 <- ggplot(gisp2) +#
geom_line(aes(1950-Age, Temperature..C.))+#
geom_text(aes(x=40, y=1.8, label="Pax Romana"))+#
geom_text(aes(x=270, y=2.3, label="Imperial Crisis"))+#
geom_rect(aes(NULL, NULL), xmin=-113, xmax=-101, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=-106, y=-1.4, label="Cimbrian War"))+#
geom_rect(aes(NULL, NULL), xmin=166, xmax=180, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=175, y=-1.4, label="Marcomannic War"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=376, y=-1.4, label="Visigothic War"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-2.3, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=550, y=-1.4, label="Migration Period"))+#
geom_line(aes(1950-Age, Temperature..C.), lwd=1.1)+#
geom_line(aes(1950-Age, Temperature..C.), colour="light blue", lwd=0.5) +#
scale_x_continuous("Year BC/AD", limits = c(-400, 800)) +#
scale_y_continuous("Temperature (C)", limits = c(-32.5, -29.5)) +#
theme_light()#
roman.gisp2
roman.gisp2 <- ggplot(gisp2) +#
geom_line(aes(1950-Age, Temperature..C.))+#
geom_text(aes(x=40, y=-31, label="Pax Romana"))+#
geom_text(aes(x=270, y=-30.5, label="Imperial Crisis"))+#
geom_rect(aes(NULL, NULL), xmin=-113, xmax=-101, ymin=-35, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=-106, y=-33, label="Cimbrian War"))+#
geom_rect(aes(NULL, NULL), xmin=166, xmax=180, ymin=-35, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=175, y=-33, label="Marcomannic War"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-35, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=376, y=-33, label="Visigothic War"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-35, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=550, y=-33, label="Migration Period"))+#
geom_line(aes(1950-Age, Temperature..C.), lwd=1.1)+#
geom_line(aes(1950-Age, Temperature..C.), colour="light blue", lwd=0.5) +#
scale_x_continuous("Year BC/AD", limits = c(-400, 800)) +#
scale_y_continuous("Temperature (C)", limits = c(-32.5, -29.5)) +#
theme_light()#
roman.gisp2
roman.gisp2 <- ggplot(gisp2) +#
geom_line(aes(1950-Age, Temperature..C.))+#
geom_text(aes(x=40, y=-31, label="Pax Romana"))+#
geom_text(aes(x=270, y=-30.5, label="Imperial Crisis"))+#
geom_rect(aes(NULL, NULL), xmin=-113, xmax=-101, ymin=-35, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=-106, y=-32, label="Cimbrian War"))+#
geom_rect(aes(NULL, NULL), xmin=166, xmax=180, ymin=-35, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=175, y=-32, label="Marcomannic War"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-35, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=376, y=-32, label="Visigothic War"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-35, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=550, y=-32, label="Migration Period"))+#
geom_line(aes(1950-Age, Temperature..C.), lwd=1.1)+#
geom_line(aes(1950-Age, Temperature..C.), colour="light blue", lwd=0.5) +#
scale_x_continuous("Year BC/AD", limits = c(-400, 800)) +#
scale_y_continuous("Temperature (C)", limits = c(-32.5, -29.5)) +#
theme_light()#
roman.gisp2
roman.gisp2 <- ggplot(gisp2) +#
geom_line(aes(1950-Age, Temperature..C.))+#
geom_text(aes(x=40, y=-30, label="Pax Romana"))+#
geom_text(aes(x=270, y=-30.9, label="Imperial Crisis"))+#
geom_rect(aes(NULL, NULL), xmin=-113, xmax=-101, ymin=-35, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=-106, y=-32.5, label="Cimbrian War"))+#
geom_rect(aes(NULL, NULL), xmin=166, xmax=180, ymin=-35, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=175, y=-32.5, label="Marcomannic War"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-35, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=376, y=-32.5, label="Visigothic War"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-35, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=550, y=-32.5, label="Migration Period"))+#
geom_line(aes(1950-Age, Temperature..C.), lwd=1.1)+#
geom_line(aes(1950-Age, Temperature..C.), colour="light blue", lwd=0.5) +#
scale_x_continuous("Year BC/AD", limits = c(-400, 800)) +#
scale_y_continuous("Temperature (C)", limits = c(-32.5, -29.5)) +#
theme_light()#
roman.gisp2
roman.gisp2 <- ggplot(gisp2) +#
geom_line(aes(1950-Age, Temperature..C.))+#
geom_text(aes(x=40, y=-30, label="Pax Romana"))+#
geom_text(aes(x=270, y=-30.2, label="Imperial Crisis"))+#
geom_rect(aes(NULL, NULL), xmin=-113, xmax=-101, ymin=-35, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=-106, y=-32.5, label="Cimbrian War"))+#
geom_rect(aes(NULL, NULL), xmin=166, xmax=180, ymin=-35, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=175, y=-32.5, label="Marcomannic War"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-35, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=376, y=-32.5, label="Visigothic War"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-35, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=550, y=-32.5, label="Migration Period"))+#
geom_line(aes(1950-Age, Temperature..C.), lwd=1.1)+#
geom_line(aes(1950-Age, Temperature..C.), colour="light blue", lwd=0.5) +#
scale_x_continuous("Year BC/AD", limits = c(-400, 800)) +#
scale_y_continuous("Temperature (C)", limits = c(-32.5, -29.5)) +#
theme_light()#
roman.gisp2
ggsave(roman.gisp2, file="/Users/lee/Dropbox/Documents/GISP and Civilization/GISP2.tiff", device="tiff", dpi=300, width=10.2, height=4.39)
ggsave(roman.gisp2, file="/Users/lee/Dropbox/Documents/GISP and Civilization/GISP2.tiff", device="tiff", dpi=300, width=10.2, height=4.39, compression = "lzw")
?ggsave
?tiff
tiff(filename = "/Users/lee/Dropbox/Documents/GISP and Civilization/GISP2.tiff", width = 10.2, height = 4.39, units = "in", pointsize = 12, res=1000, compression="lzw")
roman.gisp2
tiff(filename = "/Users/lee/Dropbox/Documents/GISP and Civilization/GISP2.tiff", width = 10.2, height = 4.39, units = "in", pointsize = 12, res=300, compression="lzw")
roman.gisp2 <- ggplot(gisp2) +#
geom_line(aes(1950-Age, Temperature..C.))+#
geom_text(aes(x=40, y=-30, label="Pax Romana"))+#
geom_text(aes(x=270, y=-30.2, label="Imperial Crisis"))+#
geom_rect(aes(NULL, NULL), xmin=-113, xmax=-101, ymin=-35, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=-106, y=-32.5, label="Cimbrian War"))+#
geom_rect(aes(NULL, NULL), xmin=166, xmax=180, ymin=-35, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=175, y=-32.5, label="Marcomannic War"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-35, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=376, y=-32.5, label="Visigothic War"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-35, ymax=2.8, fill="grey80", alpha=0.3)+#
geom_text(aes(x=550, y=-32.5, label="Migration Period"))+#
geom_line(aes(1950-Age, Temperature..C.), lwd=1.1)+#
geom_line(aes(1950-Age, Temperature..C.), colour="light blue", lwd=0.5) +#
scale_x_continuous("Year BC/AD", limits = c(-400, 800)) +#
scale_y_continuous("Temperature (C)", limits = c(-32.5, -29.5)) +#
theme_light()
roman.gisp2
library(shiny)
runApp()
library(shiny)
runAppI
runApp("~/Desktop/ArtaxMap App")
library(rsconnect)
deployApp("~/Desktop/ArtaxMap App", appName="ArtaxMap")
runApp("~/Desktop/ArtaxMap App")
deployApp("~/Desktop/ArtaxMap App", appName="ArtaxMap")
runApp("~/Desktop/ArtaxMap App")
library(shiny)
runApp("~/Desktop/5i Results App")
#Erase everything that comes before#
rm(list = ls(all = TRUE))#
#
#Compatibility#
if(.Platform$OS.type=="windows") {#
    quartz<-function() windows()#
}#
###Load Packages#
library(TTR)#
library(ggplot2)#
library(gridExtra)#
library(scales)#
library(gtable)#
library(wq)#
library(Bchron)#
library(plyr)#
library(bcp)#
#library(mgcv)#
library(reshape2)#
library(pbapply)#
library(xlsx)#
library(data.table)#
library(dplyr)#
library(akima)#
library(ggmap)#
library(ggthemes)#
library(bcp)#
####################################################
#######Calibration & Confidence Band Function#######
####################################################
####Function to organize plots in a window#
layOut = function(...) {#
    require(grid)#
    x <- list(...)#
    n <- max(sapply(x, function(x) max(x[[2]])))#
    p <- max(sapply(x, function(x) max(x[[3]])))#
    pushViewport(viewport(layout = grid.layout(n, p)))#
    for (i in seq_len(length(x))) {#
        print(x[[i]][[1]], vp = viewport(layout.pos.row = x[[i]][[2]],#
        layout.pos.col = x[[i]][[3]]))#
    }#
}#
#####Collapse Dates#
collapse.the.dates.begin <- function(sites, biogeo, general, dates, sigma) {#
    n.t <- rep(100, length(sites))#
    df <- data.frame(sites, biogeo, general, dates, sigma)#
    colnames(df) <- c("Site", "Biogeo_Uni", "St_Area_NE", "CYrBPunc", "Sigma")#
    df <- arrange(df, desc(CYrBPunc))#
    df <- arrange(df, desc(Site))#
    df <- arrange(df, desc(Biogeo_Uni))#
    df <- arrange(df, desc(St_Area_NE))#
    df$Ttest <- c(#
    (abs(df[1:(nrow(df)-1),4]-df[2:nrow(df), 4]))/((sqrt(df[2:nrow(df), 5]^2 + df[1:(nrow(df)-1),5]^2)*sqrt(1/100))), NA)#
    df$pvalue <- c((2*pt(df[1:nrow(df),6], 100, lower=FALSE)))#
    df$Collapse <- rep("No", length(sites))#
    df <- transform(df, Collapse = ifelse(pvalue > 0.05, "Yes", Collapse))#
    df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
    df <- as.data.frame(df)#
    df <- df[complete.cases(df),]#
    return(df)#
}#
#
collapse.the.dates.taxa <- function(sites, biogeo, general, dates, sigma, taxa) {#
    n.t <- rep(100, length(sites))#
    df <- data.frame(sites, biogeo, general, dates, sigma)#
    colnames(df) <- c("Site", "Biogeo_Uni", "St_Area_NE", "CYrBPunc", "Sigma", "Taxa")#
    df <- arrange(df, desc(CYrBPunc))#
    df <- arrange(df, desc(Site))#
    df <- arrange(df, desc(Biogeo_Uni))#
    df <- arrange(df, desc(St_Area_NE))#
    df$Ttest <- c(#
    (abs(df[1:(nrow(df)-1),4]-df[2:nrow(df), 4]))/((sqrt(df[2:nrow(df), 5]^2 + df[1:(nrow(df)-1),5]^2)*sqrt(1/100))), NA)#
    df$pvalue <- c((2*pt(df[1:nrow(df),6], 100, lower=FALSE)))#
    df$Collapse <- rep("No", length(sites))#
    df <- transform(df, Collapse = ifelse(pvalue > 0.05, "Yes", Collapse))#
    df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
    df <- as.data.frame(df)#
    df <- df[complete.cases(df),]#
    return(df)#
}#
####Function to organize plots in a window#
layOut = function(...) {#
    require(grid)#
    x <- list(...)#
    n <- max(sapply(x, function(x) max(x[[2]])))#
    p <- max(sapply(x, function(x) max(x[[3]])))#
    pushViewport(viewport(layout = grid.layout(n, p)))#
    for (i in seq_len(length(x))) {#
        print(x[[i]][[1]], vp = viewport(layout.pos.row = x[[i]][[2]],#
        layout.pos.col = x[[i]][[3]]))#
    }#
}#
#
####Function to maintain significant digits in plot#
fmt <- function(){#
    function(x) format(x,nsmall = 2,scientific = FALSE)#
}#
####################################################
#######Calibration & Confidence Band Function#######
####################################################
#
###Multicore apply function with status bar#
mcpblapply <- function (X, FUN, ..., mc.preschedule = TRUE, mc.set.seed = TRUE,#
mc.silent = FALSE, mc.cores = getOption("mc.cores", 2L),#
mc.cleanup = TRUE, mc.allow.recursive = TRUE, USE.NAMES = TRUE, simplify = TRUE)#
{#
    FUN <- match.fun(FUN)#
    if (!is.vector(X) || is.object(X))#
    X <- as.list(X)#
    B <- length(X)#
    if (!(interactive() && dopb() && B >= 1))#
    return(mclapply(X, FUN, ...#
    ))#
    pb <- startpb(0, B)#
    rval <- vector("list", B)#
    for (i in 1:B) {#
        rval[i] <- list(FUN(X[[i]], ...))#
        setpb(pb, i)#
    }#
    close(pb)#
    names(rval) <- names(X)#
    rval#
}#
#
mcpbsapply <- function (X, FUN, ..., mc.preschedule = TRUE, mc.set.seed = TRUE,#
mc.silent = FALSE, mc.cores = getOption("mc.cores", 2L),#
mc.cleanup = TRUE, mc.allow.recursive = TRUE, USE.NAMES = TRUE, simplify = TRUE)#
{#
    FUN <- match.fun(FUN)#
    answer <- mcpblapply(X = X, FUN = FUN,  ..., USE.NAMES = TRUE)#
    if (USE.NAMES && is.character(X) && is.null(names(answer)))#
    names(answer) <- X#
    if (!identical(simplify, FALSE) && length(answer))#
    simplify2array(answer, higher = (simplify == "array"))#
    else answer#
}#
#
mcreplicate <- function(n, expr, simplify = "array", mc.cores = getOption("mc.cores", 2L)) {#
    mcpbsapply(integer(n), eval.parent(substitute(function(...) expr)), mc.cores = getOption("mc.cores", 2L),#
    simplify = simplify)#
}#
conf.loess <- function(x, sigma, n, reps, xmin, xmax) {#
    samp.intcal <- rep("intcal13", length(x))#
    samp.slugdens <- BchronCalibrate(x, sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    res.by <- by(samp.ages$ageGrid, samp.ages$.id, median)#
    res.t <- t(res.by)#
    samp.age.grid <- c(samp.ages$ageGrid, xmin, xmax)#
    time <- seq(xmin+5, xmax-5, 10)#
    samp.grid <- sort(samp.age.grid, decreasing=TRUE)#
    samp.grid <- samp.grid[samp.grid < xmax & samp.grid > xmin]#
    samp.hist <- hist(samp.grid, breaks=length(time))#
    samp.hist <- data.frame(time, samp.hist$counts, samp.hist$counts/sum(samp.hist$counts))#
    colnames(samp.hist) <- c("Age", "Counts", "Density")#
    #samp.hist <- arrange(samp.all, desc(Age))#
    makeloess <- function(x, n){#
        time <- seq(xmin+5, xmax-5, 10)#
        samp.age <- sample(x, size=n, replace=TRUE)#
        samp.dist <- sapply(1:n, function(x) rnorm(500, samp.age, 85))#
        samp.dist <- as.vector(samp.dist)#
        samp.dist <- c(xmax, xmin, samp.dist)#
        samp.date <- tapply(samp.dist, cut(samp.dist, length(time)), length)#
        samp.loess <- lowess(time, samp.date, f=0.15)#
        samp.fitted <- samp.loess$y#
        return(samp.fitted)#
    }#
    samp.replicate <- (replicate(reps, makeloess(res.t, n)))#
    samp.replicate <- as.data.frame(samp.replicate)#
    samp.replicate[is.na(samp.replicate)] <- 0#
    samp.replicate <- sweep(samp.replicate,2,colSums(samp.replicate),`/`)#
    samp.results.replicate <- transform(samp.replicate, MEAN=apply(samp.replicate,1, mean, na.rm = TRUE))#
    samp.results.replicate <- transform(samp.results.replicate, SD=apply(samp.results.replicate,1, sd, na.rm = TRUE))#
    samp.descriptive <- data.frame(time, samp.results.replicate$MEAN, samp.results.replicate$SD)#
    colnames(samp.descriptive) <- c("Age", "Mean", "SD")#
    #samp.descriptive <- arrange(samp.descriptive, desc(Age))#
    samp.all <- data.frame(time, samp.hist$Density, samp.hist$Counts, samp.descriptive$Mean, samp.descriptive$SD, samp.replicate)#
    names(samp.all)[names(samp.all)=="time"] <- "Age"#
    names(samp.all)[names(samp.all)=="samp.descriptive.Mean"] <- "Mean"#
    names(samp.all)[names(samp.all)=="samp.descriptive.SD"] <- "SD"#
    names(samp.all)[names(samp.all)=="samp.hist.Density"] <- "Density"#
    names(samp.all)[names(samp.all)=="samp.hist.Counts"] <- "Counts"#
    samp.all <- arrange(samp.all, desc(Age))#
    return(samp.all)#
}#
taphonomic.correct <- function(stack.14C.data) {#
    df <- stack.14C.data#
    n.t <- 5.726442*(10^6)*(df$Age + 2176.4)^-1.3925309#
    lambda <- 1.3925309/(2176.4+df$Age)*100#
    lambda.r <- 1-lambda#
    n.t.relative <- n.t/128.8192#
    df$Counts.Corrected <-df$Counts/n.t.relative#
    count.mod.sum <- sum(df$Counts.Corrected)#
    df$Density.Corrected <- df$Counts.Corrected/count.mod.sum#
    return(df)#
}#
#
stack.14C.4D <- function(date, sigma, xmin, xmax, lat, long){#
    date <- c(date, 100)#
    sigma <- c(sigma, 50)#
    lat <- c(lat, 0)#
    long <- c(long, 0)#
    date.frame <- data.frame(date, sigma, lat, long)#
    names(date.frame) <- c("Date", "Sigma", "Lat", "Long")#
    date.frame <- date.frame[complete.cases(date.frame),]#
    date.sub <- subset(date.frame, (xmin-500) < Date & Date < (xmax + 500))#
    ids.cus = paste("date", 1:length(date.sub$Date), sep = "")#
    coord.sub <- data.frame(ids.cus, date.sub$Lat, date.sub$Long)#
    names(coord.sub) <- c(".id", "Lat", "Long")#
    samp.intcal <- rep("intcal13", length(date.sub$Date))#
    samp.slugdens <- BchronCalibrate(date.sub$Date, date.sub$Sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.mean <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, mean))#
    samp.sd <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, sd))#
    samp.frame <- data.frame(samp.mean, samp.sd)#
    colnames(samp.frame) <- c("Mean", "Sd")#
    samp.frame$Min <- samp.frame$Mean-date.sub$Sigma#
    samp.frame$Max <- samp.frame$Mean+date.sub$Sigma#
    samp.frame$Lat <- coord.sub$Lat#
    samp.frame$Long <- coord.sub$Long#
    samp.frame <- data.table(samp.frame)#
    lat.frame <- samp.frame[, list(Lat=Lat, ageGrid = seq(from=trunc(Min), to=trunc(Max))), by = 1:nrow(samp.frame)]#
    long.frame <- samp.frame[, list(Long=Long, ageGrid = seq(from=trunc(Min), to=trunc(Max))), by = 1:nrow(samp.frame)]#
    fin.frame <- data.frame(lat.frame$Lat, long.frame$Long, lat.frame$ageGrid)#
    colnames(fin.frame) <- c("Lat", "Long", "ageGrid")#
    return(fin.frame)#
}#
#######
stack.14C <- function(x, sigma, xmin, xmax, taxa){#
    samp.intcal <- rep("intcal13", length(x))#
    samp.slugdens <- BchronCalibrate(x, sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    fill <- seq(xmin, xmax, 1)#
    samp.age.grid <- c(samp.ages$ageGrid, fill)#
    samp.grid <- sort(samp.age.grid, decreasing=TRUE)#
    samp.grid <- samp.grid[samp.grid < xmax & samp.grid > xmin]#
    time <- seq(xmin+5, xmax-5, 10)#
    samp.hist <- hist(samp.grid, breaks=length(time))#
    samp.hist <- data.frame(time, samp.hist$counts, samp.hist$counts/sum(samp.hist$counts))#
    colnames(samp.hist) <- c("Age", "Counts", "Density")#
    corrected.samp.hist <- taphonomic.correct(samp.hist)#
    return(corrected.samp.hist)#
}#
stack.14C.taxa <- function(date, sigma, xmin, xmax, lat, long, taxa){#
    date <- as.numeric(as.vector(c(date, 49000)))#
    sigma <- as.numeric(as.vector(c(sigma, 4900)))#
    lat <- c(lat, 0)#
    long <- c(long, 0)#
    taxa <- as.vector(c(taxa, "blank"))#
    date.frame <- data.frame(date, sigma, lat, long, taxa)#
    names(date.frame) <- c("Date", "Sigma", "Lat", "Long", "Taxa")#
    date.frame <- date.frame[complete.cases(date.frame),]#
    date.sub <- subset(date.frame, (xmin) < Date & Date < (xmax))#
    ids.cus = paste("date", 1:length(date.sub$Date), sep = "")#
    coord.sub <- data.frame(ids.cus, date.sub$Lat, date.sub$Long, date.sub$Taxa)#
    names(coord.sub) <- c(".id", "Lat", "Long", "Taxa")#
    samp.intcal <- rep("intcal13", length(date.sub$Date))#
    samp.slugdens <- BchronCalibrate(date.sub$Date, date.sub$Sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.mean <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, mean))#
    samp.sd <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, sd))#
    samp.frame <- data.frame(samp.mean, samp.sd)#
    colnames(samp.frame) <- c("Mean", "Sd")#
    samp.frame$Min <- samp.frame$Mean-date.sub$Sigma#
    samp.frame$Max <- samp.frame$Mean+date.sub$Sigma#
    samp.frame$Lat <- coord.sub$Lat#
    samp.frame$Long <- coord.sub$Long#
    samp.frame$Taxa <- coord.sub$Taxa#
    samp.frame <- data.table(samp.frame)#
    lat.frame <- samp.frame[, list(Lat=Lat, ageGrid = seq(from=trunc(Min), to=trunc(Max))), by = 1:nrow(samp.frame)]#
    long.frame <- samp.frame[, list(Long=Long, ageGrid = seq(from=trunc(Min), to=trunc(Max))), by = 1:nrow(samp.frame)]#
    taxa.frame <- samp.frame[, list(Taxa=Taxa, ageGrid = seq(from=trunc(Min), to=trunc(Max))), by = 1:nrow(samp.frame)]#
    fin.frame <- data.frame(taxa.frame$Taxa, lat.frame$Lat, long.frame$Long, lat.frame$ageGrid)#
    colnames(fin.frame) <- c("Taxa", "Lat", "Long", "ageGrid")#
    return(fin.frame)#
}#
#
taxa.data <- function(stack.14C.taxa.object, taxa.names, xmin, xmax) {#
    temp.df.1 <- subset(stack.14C.taxa.object, stack.14C.taxa.object$Taxa==taxa.names)#
    temp.df <- data.frame(temp.df.1$ageGrid, factor(temp.df.1$Taxa))#
    colnames(temp.df) <- c("ageGrid", "Taxa")#
    temp.list <- split(temp.df$ageGrid, f=temp.df$Taxa)#
    temp.list <- rapply(temp.list, f=sort, how="list", decreasing=TRUE)#
    time <- seq(xmin+5, xmax-5, 10)#
    samp.hist.list <- rapply(temp.list, f=hist, how="list", breaks=length(time))#
    samp.mids <- sapply(samp.hist.list, "[[", 4)#
    samp.counts <- sapply(samp.hist.list, "[[", 2)#
    samp.density <- sapply(samp.hist.list, "[[", 3)#
    samp.mids.df <- ldply(samp.mids, data.frame)#
    samp.counts.df <- ldply(samp.counts, data.frame)#
    samp.density.df <- ldply(samp.density, data.frame)#
    samp.hist <- data.frame(samp.mids.df[1], samp.mids.df[2], samp.counts.df[2], samp.density.df[2])#
    colnames(samp.hist) <- c("Taxa", "Age", "Counts", "Density")#
    corrected.samp.hist <- taphonomic.correct(samp.hist)#
    return(corrected.samp.hist)#
}#
#
taxa.data.single <- function(stack.14C.taxa.object, taxa.names, xmin, xmax) {#
    temp.df.1 <- subset(stack.14C.taxa.object, stack.14C.taxa.object$Taxa==taxa.names)#
    temp.df <- data.frame(temp.df.1$ageGrid, factor(temp.df.1$Taxa))#
    colnames(temp.df) <- c("ageGrid", "Taxa")#
    temp.list <- split(temp.df$ageGrid, f=temp.df$Taxa)#
    temp.list <- rapply(temp.list, f=sort, how="list", decreasing=TRUE)#
    time <- seq(xmin+5, xmax-5, 10)#
    samp.hist.list <- rapply(temp.list, f=hist, how="list", breaks=length(time))#
    samp.mids <- sapply(samp.hist.list, "[[", 4)#
    samp.counts <- sapply(samp.hist.list, "[[", 2)#
    samp.density <- sapply(samp.hist.list, "[[", 3)#
    samp.mids.df <- ldply(samp.mids, data.frame)#
    samp.counts.df <- ldply(samp.counts, data.frame)#
    samp.density.df <- ldply(samp.density, data.frame)#
    samp.hist <- data.frame(samp.mids.df[1], samp.counts.df[1], samp.density.df[1])#
    colnames(samp.hist) <- c("Age", "Counts", "Density")#
    corrected.samp.hist <- taphonomic.correct(samp.hist)#
    return(corrected.samp.hist)#
}#
median.stack.14C <- function(x, sigma, xmin, xmax){#
    samp.intcal <- rep("intcal13", length(x))#
    samp.slugdens <- BchronCalibrate(x, sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.median <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, median))#
    medians.all <-as.vector(samp.median[,1])#
    n <- length(medians.all)#
    medians <- medians.all[medians.all < xmax & medians.all > xmin]#
    return(medians)#
}#
######Function to Generate Confidence Bands around SCDRD#
conf.cal.loess <- function(dates, sigma, n, reps, sites, xmin, xmax, ..., cores = getOption("mc.cores", 2L), collapse.dates=FALSE) {#
    collapse.the.dates <- function(sites, dates, sigma) {#
        n.t <- rep(100, length(sites))#
        df <- data.frame(sites, dates, sigma)#
        colnames(df) <- c("Sites", "Date", "Sigma")#
        df <- arrange(df, desc(Date))#
        df <- arrange(df, desc(Sites))#
        df$Ttest <- c(#
        (abs(df[1:(nrow(df)-1),2]-df[2:nrow(df), 2]))/((sqrt(df[2:nrow(df), 3]^2 + df[1:(nrow(df)-1),3]^2)*sqrt(1/100))), NA)#
        df$pvalue <- c((2*pt(df[1:nrow(df),4], 100, lower=FALSE)))#
        df$Collapse <- rep("No", length(sites))#
        df <- transform(df, Collapse = ifelse(pvalue > 0.05, "Yes", Collapse))#
        df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
        df <- as.data.frame(df)#
        df <- df[complete.cases(df),]#
        return(df)#
    }#
    uncollapse.the.dates <- function(sites, dates, sigma) {#
        df <- data.frame(sites, dates, sigma)#
        colnames(df) <- c("Sites", "Date", "Sigma")#
        return(df)#
    }#
    date.data <- if(isTRUE(collapse.dates)){#
        collapse.the.dates(sites, dates, sigma)#
    } else {#
        uncollapse.the.dates(sites, dates, sigma)#
    }#
    samp.intcal <- rep("intcal13", length(date.data$Date))#
    samp.slugdens <- BchronCalibrate(date.data$Date, date.data$Sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.mean <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, mean))#
    samp.sd <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, sd))#
    samp.frame <- data.frame(samp.mean, samp.sd, samp.ages$.id)#
    colnames(samp.frame) <- c("Mean", "Sd", "Id")#
    samp.frame$Min <- samp.frame$Mean-date.sub$Sigma*2#
    samp.frame$Max <- samp.frame$Mean+date.sub$Sigma*2#
    id.frame <- samp.frame[, list(Id=Id, ageGrid = seq(from=trunc(Min), to=trunc(Max))), by = 1:nrow(samp.frame)]#
    colnames(id.frame) <- c("Id", "ageGrid")#
    res.by <- by(samp.frame$ageGrid, samp.frame$.id, median)#
    res.t <- t(res.by)#
    fill <- seq(xmin, xmax, 1)#
    samp.age.grid <- c(samp.frame$ageGrid, fill)#
    time <- seq(xmin+5, xmax-5, 10)#
    samp.grid <- sort(samp.age.grid, decreasing=TRUE)#
    samp.grid <- samp.grid[samp.grid < xmax & samp.grid > xmin]#
    samp.hist <- hist(samp.grid, breaks=length(time))#
    samp.hist <- data.frame(time, samp.hist$counts, samp.hist$counts/sum(samp.hist$counts))#
    colnames(samp.hist) <- c("Age", "Counts", "Density")#
    #samp.hist <- arrange(samp.all, desc(Age))#
    makeloess <- function(dates, n){#
        time <- seq(xmin+5, xmax-5, 10)#
        n.s <- length(dates)#
        samp.order <- sample(n.s, size=n, replace=TRUE)#
        samp.dist.n <- samp.slugdens[samp.order]#
        temp.ages <- ldply(samp.dist.n, data.frame)#
        temp.age.grid <- c(temp.ages$ageGrid, fill)#
        temp.grid <- temp.age.grid[temp.age.grid < xmax & samp.grid > xmin]#
        samp.dist <- c(fill, temp.grid)#
        samp.dist <- as.vector(samp.dist)#
        samp.dist <- c(xmax, xmin, samp.dist)#
        samp.date <- tapply(samp.dist, cut(samp.dist, length(time)), length)#
        samp.loess <- lowess(time, samp.date, f=0.15)#
        samp.fitted <- samp.loess$y#
        return(samp.fitted)#
    }#
    samp.replicate <- (mcreplicate(reps, makeloess(dates, n)))#
    samp.replicate.dat <- as.data.frame(samp.replicate)#
    samp.replicate.dat[is.na(samp.replicate.dat)] <- 0#
    samp.replicated <- sweep(samp.replicate.dat,2,colSums(samp.replicate.dat),`/`)#
    samp.results.replicated.m <- transform(samp.replicated, MEAN=apply(X=samp.replicated, MARGIN=1, FUN=mean, na.rm = TRUE))#
    samp.results.replicated.s <- transform(samp.replicated, SD=apply(X=samp.replicated, MARGIN=1, FUN=sd, na.rm = TRUE))#
    samp.descriptive <- data.frame(time, samp.results.replicated.m$MEAN, samp.results.replicated.s$SD)#
    colnames(samp.descriptive) <- c("Age", "Mean", "SD")#
    #samp.descriptive <- arrange(samp.descriptive, desc(Age))#
    samp.all <- data.frame(time, samp.hist$Density, samp.hist$Counts, samp.descriptive$Mean, samp.descriptive$SD)#
    names(samp.all)[names(samp.all)=="time"] <- "Age"#
    names(samp.all)[names(samp.all)=="samp.descriptive.Mean"] <- "Mean"#
    names(samp.all)[names(samp.all)=="samp.descriptive.SD"] <- "SD"#
    names(samp.all)[names(samp.all)=="samp.hist.Density"] <- "Density"#
    names(samp.all)[names(samp.all)=="samp.hist.Counts"] <- "Counts"#
    samp.all <- arrange(samp.all, desc(Age))#
    return(samp.all)#
}#
######Function to Generate Confidence Bands around SCDRD#
conf.cal.loess.bad <- function(dates, sigma, n, reps, sites, xmin, xmax, ..., cores = getOption("mc.cores", 2L), collapse.dates=FALSE) {#
    collapse.the.dates <- function(sites, dates, sigma) {#
        n.t <- rep(100, length(sites))#
        df <- data.frame(sites, dates, sigma)#
        colnames(df) <- c("Sites", "Date", "Sigma")#
        df <- arrange(df, desc(Date))#
        df <- arrange(df, desc(Sites))#
        df$Ttest <- c(#
        (abs(df[1:(nrow(df)-1),2]-df[2:nrow(df), 2]))/((sqrt(df[2:nrow(df), 3]^2 + df[1:(nrow(df)-1),3]^2)*sqrt(1/100))), NA)#
        df$pvalue <- c((2*pt(df[1:nrow(df),4], 100, lower=FALSE)))#
        df$Collapse <- rep("No", length(sites))#
        df <- transform(df, Collapse = ifelse(pvalue > 0.05, "Yes", Collapse))#
        df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
        df <- as.data.frame(df)#
        df <- df[complete.cases(df),]#
        return(df)#
    }#
    uncollapse.the.dates <- function(sites, dates, sigma) {#
        df <- data.frame(sites, dates, sigma)#
        colnames(df) <- c("Sites", "Date", "Sigma")#
        return(df)#
    }#
    date.data <- if(isTRUE(collapse.dates)){#
        collapse.the.dates(sites, dates, sigma)#
    } else {#
        uncollapse.the.dates(sites, dates, sigma)#
    }#
    samp.intcal <- rep("intcal13", length(date.data$Date))#
    samp.slugdens <- BchronCalibrate(date.data$Date, date.data$Sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.mean <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, mean))#
    samp.sd <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, sd))#
    samp.frame <- data.frame(samp.mean, samp.sd, samp.ages$.id)#
    colnames(samp.frame) <- c("Mean", "Sd", "Id")#
    samp.frame$Min <- samp.frame$Mean-date.sub$Sigma*2#
    samp.frame$Max <- samp.frame$Mean+date.sub$Sigma*2#
    id.frame <- samp.frame[, list(Id=Id, ageGrid = seq(from=trunc(Min), to=trunc(Max))), by = 1:nrow(samp.frame)]#
    colnames(id.frame) <- c("Id", "ageGrid")#
    res.by <- by(samp.frame$ageGrid, samp.frame$.id, median)#
    res.t <- t(res.by)#
    fill <- seq(xmin, xmax, 1)#
    samp.age.grid <- c(samp.frame$ageGrid, fill)#
    time <- seq(xmin+5, xmax-5, 10)#
    samp.grid <- sort(samp.age.grid, decreasing=TRUE)#
    samp.grid <- samp.grid[samp.grid < xmax & samp.grid > xmin]#
    samp.hist <- hist(samp.grid, breaks=length(time))#
    samp.hist <- data.frame(time, samp.hist$counts, samp.hist$counts/sum(samp.hist$counts))#
    colnames(samp.hist) <- c("Age", "Counts", "Density")#
    #samp.hist <- arrange(samp.all, desc(Age))#
    makeloess <- function(dates, n){#
        time <- seq(xmin+5, xmax-5, 10)#
        n.s <- length(dates)#
        samp.order <- sample(n.s, size=n, replace=TRUE)#
        samp.dist.n <- samp.slugdens[samp.order]#
        temp.ages <- ldply(samp.dist.n, data.frame)#
        temp.age.grid <- c(temp.ages$ageGrid, fill)#
        temp.grid <- temp.age.grid[temp.age.grid < xmax & samp.grid > xmin]#
        samp.dist <- c(fill, temp.grid)#
        samp.dist <- as.vector(samp.dist)#
        samp.dist <- c(xmax, xmin, samp.dist)#
        samp.date <- tapply(samp.dist, cut(samp.dist, length(time)), length)#
        samp.loess <- lowess(time, samp.date, f=0.15)#
        samp.fitted <- samp.loess$y#
        return(samp.fitted)#
    }#
    samp.replicate <- (mcreplicate(reps, makeloess(dates, n)))#
    samp.replicate.dat <- as.data.frame(samp.replicate)#
    samp.replicate.dat[is.na(samp.replicate.dat)] <- 0#
    samp.replicated <- sweep(samp.replicate.dat,2,colSums(samp.replicate.dat),`/`)#
    samp.results.replicated.m <- transform(samp.replicated, MEAN=apply(X=samp.replicated, MARGIN=1, FUN=mean, na.rm = TRUE))#
    samp.results.replicated.s <- transform(samp.replicated, SD=apply(X=samp.replicated, MARGIN=1, FUN=sd, na.rm = TRUE))#
    samp.descriptive <- data.frame(time, samp.results.replicated.m$MEAN, samp.results.replicated.s$SD)#
    colnames(samp.descriptive) <- c("Age", "Mean", "SD")#
    #samp.descriptive <- arrange(samp.descriptive, desc(Age))#
    samp.all <- data.frame(time, samp.hist$Density, samp.hist$Counts, samp.descriptive$Mean, samp.descriptive$SD)#
    names(samp.all)[names(samp.all)=="time"] <- "Age"#
    names(samp.all)[names(samp.all)=="samp.descriptive.Mean"] <- "Mean"#
    names(samp.all)[names(samp.all)=="samp.descriptive.SD"] <- "SD"#
    names(samp.all)[names(samp.all)=="samp.hist.Density"] <- "Density"#
    names(samp.all)[names(samp.all)=="samp.hist.Counts"] <- "Counts"#
    samp.all <- arrange(samp.all, desc(Age))#
    return(samp.all)#
}#
#
###Traditional SCDPD#
BchronDensityCollapse <- function (dates, sigma, sites,  dfs = rep(100, length(dates)), numMix = 30,#
iterations = 10000, burn = 2000, thin = 8, updateAges = FALSE, collapse.dates=FALSE)#
{#
    collapse.the.dates <- function(sites, dates, sigma) {#
        n.t <- rep(100, length(sites))#
        df <- data.frame(sites, dates, sigma)#
        colnames(df) <- c("Sites", "Date", "Sigma")#
        df <- arrange(df, desc(Date))#
        df <- arrange(df, desc(Sites))#
        df$Ttest <- c(#
        (abs(df[1:(nrow(df)-1),2]-df[2:nrow(df), 2]))/((sqrt(df[2:nrow(df), 3]^2 + df[1:(nrow(df)-1),3]^2)*sqrt(1/100))), NA)#
        df$pvalue <- c((2*pt(df[1:nrow(df),4], 100, lower=FALSE)))#
        df$Collapse <- rep("No", length(sites))#
        df <- transform(df, Collapse = ifelse(pvalue > 0.05, "Yes", Collapse))#
        df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
        return(df)#
    }#
    uncollapse.the.dates <- function(sites, dates, sigma) {#
        df <- data.frame(sites, dates, sigma)#
        colnames(df) <- c("Sites", "Date", "Sigma")#
        return(df)#
    }#
    date.data <- if(isTRUE(collapse.dates)){#
        collapse.the.dates(sites, dates, sigma)#
    } else {#
        uncollapse.the.dates(sites, dates, sigma)#
    }#
    pathToCalCurves = system.file("data",#
    package = "Bchron")#
    calCurves <- rep("intcal13", length(date.data$Date))#
    ages <- date.data$Date#
    ageSds <- date.data$Sigma#
    if (length(ages) != length(ageSds))#
    stop("ages and 1-sigma errors must be same length")#
    if (length(ages) != length(calCurves))#
    stop("ages and Calibration curves must be same length")#
    x = BchronCalibrate(ages = ages, ageSds = ageSds, calCurves = calCurves,#
    pathToCalCurves = pathToCalCurves, eps = 0, dfs = rep(100,#
    length(ages)))#
    xSmall = BchronCalibrate(ages = ages, ageSds = ageSds, calCurves = calCurves,#
    pathToCalCurves = pathToCalCurves, dfs = rep(100, length(ages)))#
    n = length(x)#
    thetaRange = range(xSmall[[1]]$ageGrid)#
    for (i in 2:n) thetaRange = range(c(thetaRange, xSmall[[i]]$ageGrid))#
    offset = vector(length = n)#
    for (i in 1:n) {#
        offset[i] = ifelse(x[[i]]$calCurve == "normal", 61, 0)#
    }#
    gauss <- function(x, mu, sig) {#
        u <- (x - mu)/sig#
        y <- exp(-u * u/2)#
        y#
    }#
    gbase <- function(x, mus) {#
        sig <- (mus[2] - mus[1])/2#
        G <- outer(x, mus, gauss, sig)#
        G#
    }#
    clrInv = function(phi) {#
        return(exp(phi)/sum(exp(phi)))#
    }#
    J = numMix#
    mu = seq(thetaRange[1], thetaRange[2], length = numMix)#
    theta = vector(length = n)#
    for (j in 1:n) theta[j] = round(stats::rnorm(1, mean = x[[j]]$ageGrid[match(max(x[[j]]$densities),#
    x[[j]]$densities)], sd = ageSds[j]), 3)#
    phi = c(stats::runif(J - 1, -10, 10), 0)#
    p = as.numeric(clrInv(phi))#
    G = gbase(theta, mu)#
    remaining = (iterations - burn)/thin#
    thetaStore = matrix(ncol = length(theta), nrow = remaining)#
    pStore = matrix(ncol = J, nrow = remaining)#
    thetaAll = matrix(NA, ncol = n, nrow = iterations)#
    for (j in 1:n) thetaAll[, j] = sample(xSmall[[j]]$ageGrid,#
    size = iterations, prob = xSmall[[j]]$densities, replace = TRUE)#
    mu2 = mu#
    sigma2 = (mu[2] - mu[1])/2#
    my_dnorm = function(x) stats::dnorm(x, mean = mu2, sd = sigma2)#
    pb = utils::txtProgressBar(min = 1, max = iterations, style = 3,#
    width = 60, title = "Running BchronDensity")#
    for (i in 1:iterations) {#
        utils::setTxtProgressBar(pb, i)#
        if (i > burn & i%%thin == 0) {#
            ind = (i - burn)/thin#
            thetaStore[ind, ] = theta#
            pStore[ind, ] = p#
        }#
        if (updateAges) {#
            for (j in 1:n) {#
                thetaNew = round(stats::rnorm(1, theta[j], 0.5),#
                3)#
                thetaNewMatch = as.integer(thetaNew + offset[j]) +#
                1#
                thetaNewLogDens = max(log(x[[j]]$densities[thetaNewMatch]),#
                -1e+06)#
                priorNew.dens = sum(p * stats::dnorm(thetaNew,#
                mean = mu2, sd = sigma2))#
                thetaMatch = as.integer(theta[j] + offset[j]) +#
                1#
                thetaLogDens = max(log(x[[j]]$densities[thetaMatch]),#
                -1e+06)#
                priorDens = sum(p * stats::dnorm(theta[j], mean = mu2,#
                sd = sigma2))#
                logRtheta = thetaNewLogDens - thetaLogDens +#
                log(priorNew.dens) - log(priorDens)#
                if (stats::runif(1) < exp(logRtheta))#
                theta[j] = thetaNew#
            }#
        }#
        else {#
            theta = thetaAll[i, ]#
        }#
        for (j in 1:(J - 1)) {#
            phiNew = stats::rnorm(1, phi[j], 1)#
            phiAllNew = phi#
            phiAllNew[j] = phiNew#
            pNew = as.numeric(clrInv(phiAllNew))#
            phiNewLogDens = sum(log(G %*% pNew))#
            phiLogDens = sum(log(G %*% p))#
            logRphi = phiNewLogDens - phiLogDens + stats::dunif(phiNew,#
            -10, 10, log = TRUE) - stats::dunif(phi[j], -10,#
            10, log = TRUE)#
            if (stats::runif(1) < exp(logRphi)) {#
                phi[j] = phiNew#
                p = as.numeric(clrInv(phi))#
            }#
        }#
    }#
    output = list(theta = thetaStore, p = pStore, mu = mu, calAges = xSmall,#
    G = G)#
    class(output) = "BchronDensityRun"#
    return(output)#
}#
#
###Function to modify existing SCDPD from BchronDensity (modified from Bchron)#
SlugDens.t <- function (x, xmin, xmax)#
{#
    n = length(x$calAges)#
    thetaRange = range(x$calAges[[1]]$ageGrid)#
    for (i in 2:n) thetaRange = range(c(thetaRange, x$calAges[[i]]$ageGrid))#
    dateGrid = seq(xmin, xmax, length = 1000)#
    gauss <- function(x, mu, sig) {#
        u <- (x - mu)/sig#
        y <- exp(-u * u/2)#
        y#
    }#
    gbase <- function(x, mus) {#
        sig <- (mus[2] - mus[1])/2#
        G <- outer(x, mus, gauss, sig)#
        G#
    }#
    Gstar = gbase(dateGrid, x$mu)#
    dens = vector(length = length(dateGrid))#
    for (i in 1:nrow(x$p)) {#
        dens = dens + Gstar %*% x$p[i, ]#
    }#
    densFinal = dens/sum(dens)#
    slugbase <- data.frame(dateGrid,densFinal)#
    colnames(slugbase) <- c("Age", "Density")#
    slugbase <- arrange(slugbase, desc(Age))#
    return(slugbase)#
}#
#
SlugSig <- function(x, sigma, n, reps, xmin, xmax) {#
    time <- seq(xmin+5, xmax-5, 10)#
    samp.intcal <- rep("intcal13", length(x))#
    samp.slugdens <- BchronDensity(x, sigma, samp.intcal, numMix = 30, iterations=10000, burn=2000, thin=8, updateAges=FALSE)#
    samp.hist <- SlugDens.t(samp.slugdens, xmin, xmax)#
    makeloess <- function(x, n){#
        time <- seq(xmin+5, xmax-5, 10)#
        samp.14C <- sample(x, size=n, replace=TRUE)#
        samp.sig <- sample(sigma, size=n, replace=TRUE)#
        samp.dist.n <- BchronDensity(samp.14C, samp.sig, rep("intcal13", n), numMix = 30, iterations=10000, burn=2000, thin=8, updateAges=FALSE)#
        samp.dist <- SlugDens.t(samp.dist.n, xmin, xmax)#
        samp.loess <- lowess(samp.dist$Age, samp.dist$Density, f=0.15)#
        samp.fitted <- samp.loess$y#
        return(samp.fitted)#
    }#
    samp.replicate <- (pbreplicate(reps, makeloess(x, n)))#
    samp.replicate <- as.data.frame(samp.replicate)#
    samp.replicate[is.na(samp.replicate)] <- 0#
    samp.replicate <- sweep(samp.replicate,2,colSums(samp.replicate),`/`)#
    samp.results.replicate <- transform(samp.replicate, MEAN=apply(samp.replicate,1, mean, na.rm = TRUE))#
    samp.results.replicate <- transform(samp.results.replicate, SD=apply(samp.results.replicate,1, sd, na.rm = TRUE))#
    samp.descriptive <- data.frame(samp.hist$Age, samp.results.replicate$MEAN, samp.results.replicate$SD)#
    colnames(samp.descriptive) <- c("Age", "Mean", "SD")#
    #samp.descriptive <- arrange(samp.descriptive, desc(Age))#
    samp.all <- data.frame(samp.hist$Age, samp.hist$Density, samp.descriptive$Mean, samp.descriptive$SD, samp.replicate)#
    names(samp.all)[names(samp.all)=="samp.hist.Age"] <- "Age"#
    names(samp.all)[names(samp.all)=="samp.descriptive.Mean"] <- "Mean"#
    names(samp.all)[names(samp.all)=="samp.descriptive.SD"] <- "SD"#
    names(samp.all)[names(samp.all)=="samp.hist.Density"] <- "Density"#
    samp.all <- arrange(samp.all, desc(Age))#
    return(samp.all)#
}#
####Function to maintain significant digits in plot#
fmt <- function(){#
    function(x) format(x,nsmall = 4,scientific = FALSE)#
}#
collapse.the.dates.begin <- function(sites, region, taxa, dates, sigma, lat, long, datemin, datemax) {#
    n.t <- rep(100, length(sites))#
    df.1 <- data.frame(sites, region, dates, sigma, lat, long)#
    colnames(df.1) <- c("Site", "Region", "X14C.year", "Sigma", "Lat", "Long")#
    df <- subset(df.1, df.1$X14C.year < datemax & df.1$X14C.year > datemin)#
    df <- arrange(df, desc(X14C.year))#
    df <- arrange(df, desc(Site))#
    df <- arrange(df, desc(Region))#
    df$Ttest <- c(#
    (abs(df[1:(nrow(df)-1),3]-df[2:nrow(df), 3]))/((sqrt(df[2:nrow(df), 4]^2 + df[1:(nrow(df)-1),4]^2)*sqrt(1/100))), NA)#
    df$pvalue <- c((2*pt(df[1:nrow(df),7], 100, lower=FALSE)))#
    df$Collapse <- rep("No", length(df$Site))#
    df <- transform(df, Collapse = ifelse(pvalue > 0.05, "Yes", Collapse))#
    df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
    df <- as.data.frame(df)#
    df <- df[complete.cases(df),]#
    return(df)#
}#
collapse.the.dates.taxa <- function(sites, region, taxa, dates, sigma, lat, long, datemin, datemax) {#
    n.t <- rep(100, length(sites))#
    df.1 <- data.frame(sites, region, dates, sigma, lat, long, taxa)#
    colnames(df.1) <- c("Site", "Region", "X14C.year", "Sigma", "Lat", "Long", "Taxa")#
    df <- subset(df.1, df.1$X14C.year < datemax & df.1$X14C.year > datemin)#
    df <- arrange(df, desc(X14C.year))#
    df <- arrange(df, desc(Site))#
    df <- arrange(df, desc(Region))#
    df$Ttest <- c(#
    (abs(df[1:(nrow(df)-1),3]-df[2:nrow(df), 3]))/((sqrt(df[2:nrow(df), 4]^2 + df[1:(nrow(df)-1),4]^2)*sqrt(1/100))), NA)#
    df$pvalue <- c((2*pt(df[1:nrow(df),8], 100, lower=FALSE)))#
    df$Collapse <- rep("No", length(df$Site))#
    df <- transform(df, Collapse = ifelse(pvalue > 0.05, "Yes", Collapse))#
    df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
    df <- as.data.frame(df)#
    df <- df[complete.cases(df),]#
    return(df)#
}#
#
site.median <- function(sites, region, dates, sigma) {#
    n.t <- rep(100, length(sites))#
    df <- data.frame(sites, region, dates, sigma)#
    colnames(df) <- c("Site", "Region", "X14C.year", "Sigma")#
    df <- arrange(df, desc(X14C.year))#
    df <- arrange(df, desc(Region))#
    df <- arrange(df, desc(Site))#
    df$Collapse <- rep("No", length(sites))#
    df <- transform(df, Collapse = ifelse(df[nrow(df)] > 0.05, "Yes", Collapse))#
    df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
    df <- as.data.frame(df)#
    df <- df[complete.cases(df),]#
    return(df)#
}#
site.time <- function(sites, dates, sigma, xmin, xmax, time) {#
    df <- data.frame(sites, dates, sigma)#
    colnames(df) <- c("Site",  "X14C.year", "Sigma")#
    df <- arrange(df, desc(X14C.year))#
    df <- arrange(df, desc(Site))#
    site.frame <- aggregate(x=df$X14C.year, by=list(df$Site), FUN=mean)#
    site.vector <- site.frame$x#
    site.frame.sig <- aggregate(x=df$Sigma, by=list(df$Site), FUN=mean)#
    site.vector.sig <- site.frame.sig$x#
    samp.intcal <- rep("intcal13", length(site.vector))#
    samp.slugdens <- BchronCalibrate(site.vector, site.vector.sig, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.median <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, median))#
    medians.all <-as.vector(samp.median[,1])#
    medians <- medians.all[medians.all < xmax & medians.all > xmin]#
    median.simple <- round((medians/100000), digits=2)*100000#
    median.table <- table(median.simple)#
    median.values <- as.numeric(paste(median.table))#
    median.frame <- data.frame(t(median.values))#
    colnames(median.frame) <- names(median.table)#
    median.t <- data.frame(t(median.frame))#
    median.df <- data.frame(add_rownames(median.t, "VALUE"))#
    colnames(median.df) <- c("Millenium", "Site")#
    median.df <- median.df[with(median.df, order(as.numeric(Millenium))), ]#
    null <- rep(0, length(time))#
    null.frame <- t(data.frame(null))#
    colnames(null.frame) <- time#
    null.t <- data.frame(t(null.frame))#
    null.df <- data.frame(add_rownames(null.t, "VALUE"))#
    colnames(null.df) <- c("Millenium", "Site")#
    all.frame <- merge(null.df, median.df, all=TRUE, by="Millenium")#
    all.frame[is.na(all.frame)] <- 0#
    all.frame <- all.frame[with(all.frame, order(as.numeric(Millenium))), ]#
    the.result <- data.frame(all.frame$Millenium, all.frame$Site.y)#
    colnames(the.result) <- c("Millenium", "Sites")#
    scaled <- as.vector(apply(data.frame(the.result$Sites), 2, function(x) scale(x)))#
    scaled.mean <- mean(scaled)#
    scaled.sd <- sd(scaled)#
    the.result$z.score <- (scaled-scaled.mean)/scaled.sd#
    the.result$p.value <- pnorm(the.result$z.score, lower.tail=FALSE)#
    return(format(the.result, digits=2))#
}#
median.stack.14C <- function(dates, sigma, sites, xmin, xmax, time){#
    samp.intcal <- rep("intcal13", length(dates))#
    samp.slugdens <- BchronCalibrate(dates, sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.median <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, median))#
    medians.all <-as.vector(samp.median[,1])#
    medians <- medians.all[medians.all < xmax & medians.all > xmin]#
    median.simple <- round((medians/100000), digits=2)*100000#
    median.table <- table(median.simple)#
    median.values <- as.numeric(paste(median.table))#
    median.frame <- data.frame(t(median.values))#
    colnames(median.frame) <- names(median.table)#
    median.t <- data.frame(t(median.frame))#
    median.df <- data.frame(add_rownames(median.t, "VALUE"))#
    colnames(median.df) <- c("Millenium", "Site")#
    median.df <- median.df[with(median.df, order(as.numeric(Millenium))), ]#
    null <- rep(0, length(time))#
    null.frame <- t(data.frame(null))#
    colnames(null.frame) <- time#
    null.t <- data.frame(t(null.frame))#
    null.df <- data.frame(add_rownames(null.t, "VALUE"))#
    colnames(null.df) <- c("Millenium", "Site")#
    all.frame <- merge(null.df, median.df, all=TRUE, by="Millenium")#
    all.frame[is.na(all.frame)] <- 0#
    all.frame <- all.frame[with(all.frame, order(as.numeric(Millenium))), ]#
    the.result <- data.frame(all.frame$Millenium, all.frame$Site.y)#
    colnames(the.result) <- c("Millenium", "Sites")#
    scaled <- as.vector(apply(data.frame(the.result$Sites), 2, function(x) scale(x)))#
    scaled.mean <- mean(scaled)#
    scaled.sd <- sd(scaled)#
    the.result$z.score <- (scaled-scaled.mean)/scaled.sd#
    the.result$p.value <- pnorm(the.result$z.score, lower.tail=FALSE)#
    return(format(the.result, digits=2))#
}#
site.time.half <- function(sites, dates, sigma, xmin, xmax, time) {#
    df <- data.frame(sites, dates, sigma)#
    colnames(df) <- c("Site",  "X14C.year", "Sigma")#
    df <- arrange(df, desc(X14C.year))#
    df <- arrange(df, desc(Site))#
    site.frame <- aggregate(x=df$X14C.year, by=list(df$Site), FUN=mean)#
    site.vector <- site.frame$x#
    site.frame.sig <- aggregate(x=df$Sigma, by=list(df$Site), FUN=mean)#
    site.vector.sig <- site.frame.sig$x#
    samp.intcal <- rep("intcal13", length(site.vector))#
    samp.slugdens <- BchronCalibrate(site.vector, site.vector.sig, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.median <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, median))#
    medians.all <-as.vector(samp.median[,1])#
    medians <- medians.all[medians.all < xmax & medians.all > xmin]#
    return(medians)#
}#
median.stack.14C.half <- function(x, sigma, sites, xmin, xmax){#
    samp.intcal <- rep("intcal13", length(x))#
    samp.slugdens <- BchronCalibrate(x, sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.median <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, median))#
    medians.all <-as.vector(samp.median[,1])#
    medians <- medians.all[medians.all < xmax & medians.all > xmin]#
    return(medians)#
}#
nao.index <- read.csv(file="/Users/lee/Dropbox/Documents/GISP and Civilization/NAO/NAO Index-Table 1.csv")#
nao.index <- arrange(nao.index, Year)
roman.gisp2 <- ggplot(gisp2) +#
geom_line(aes(1950-Age, Temperature..C.))+#
geom_text(aes(x=40, y=-30, label="Pax Romana"))+#
geom_text(aes(x=270, y=-30.2, label="Imperial Crisis"))+#
geom_rect(aes(NULL, NULL), xmin=-113, xmax=-101, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
geom_text(aes(x=-106, y=-32.5, label="Cimbrian War"))+#
geom_rect(aes(NULL, NULL), xmin=166, xmax=180, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
geom_text(aes(x=175, y=-32.5, label="Marcomannic War"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
geom_text(aes(x=376, y=-32.5, label="Visigothic War"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
geom_text(aes(x=550, y=-32.5, label="Migration Period"))+#
geom_line(aes(1950-Age, Temperature..C.), lwd=1.1)+#
geom_line(aes(1950-Age, Temperature..C.), colour="light blue", lwd=0.5) +#
scale_x_continuous("Year BC/AD", limits = c(-400, 800)) +#
scale_y_continuous("Temperature (C)", limits = c(-32.5, -29.5)) +#
theme_light()#
roman.gisp2#
#
ggsave(roman.gisp2, file="/Users/lee/Dropbox/Documents/GISP and Civilization/GISP2.tiff", device="tiff", dpi=300, width=10.2, height=4.39, compression = "lzw")
gisp2 <- read.csv(file="/Users/lee/Dropbox/Documents/GISP and Civilization/gisp2.csv")#
#
roman.gisp2 <- ggplot(gisp2) +#
geom_line(aes(1950-Age, Temperature..C.))+#
geom_text(aes(x=40, y=-30, label="Pax Romana"))+#
geom_text(aes(x=270, y=-30.2, label="Imperial Crisis"))+#
geom_rect(aes(NULL, NULL), xmin=-113, xmax=-101, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
geom_text(aes(x=-106, y=-32.5, label="Cimbrian War"))+#
geom_rect(aes(NULL, NULL), xmin=166, xmax=180, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
geom_text(aes(x=175, y=-32.5, label="Marcomannic War"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
geom_text(aes(x=376, y=-32.5, label="Visigothic War"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
geom_text(aes(x=550, y=-32.5, label="Migration Period"))+#
geom_line(aes(1950-Age, Temperature..C.), lwd=1.1)+#
geom_line(aes(1950-Age, Temperature..C.), colour="light blue", lwd=0.5) +#
scale_x_continuous("Year BC/AD", limits = c(-400, 800)) +#
scale_y_continuous("Temperature (C)", limits = c(-32.5, -29.5)) +#
theme_light()#
roman.gisp2#
#
ggsave(roman.gisp2, file="/Users/lee/Dropbox/Documents/GISP and Civilization/GISP2.tiff", device="tiff", dpi=300, width=10.2, height=4.39, compression = "lzw")
iberia <- <- read.csv(file="~/Dropbox/4.2 ky event/Radiocarbon Final/All Iberia/Just Dates-Table 1.csv")
ls(iberia)
iberia <- read.csv(file="~/Dropbox/4.2 ky event/Radiocarbon Final/All Iberia/Just Dates-Table 1.csv")
ls(iberia)
iberia.col <- collapse.the.dates.begin(sites=iberia$Site, region=iberia$Region, dates=as.numeric(as.vector(iberia$X14C.Yr.BP.uncal)), sigma=as.numeric(as.vector(iberia$Sigma)), lat=iberia$Lat.in.Dec, long=iberia$Long.in.Dec, datemin = 100, datemax = 45000)
iberia.stack <- stack.14C(iberia$X14C.year, iberia$Sigma, xmin=0, xmax= 40000)
iberia.stack <- stack.14C(iberia.col$X14C.year, iberia.col$Sigma, xmin=0, xmax= 40000)
iberia.plot <- ggplot(iberia.stack) +#
geom_text(aes(x=40, y=.002, label="Pax Romana"))+#
geom_text(aes(x=270, y=.00177, label="Imperial Crisis"))+#
geom_rect(aes(NULL, NULL), xmin=-43, xmax=-30, ymin=-2.3, ymax=2.8, fill="grey90", alpha=0.3)+#
geom_text(aes(x=-38, y=.0016, label="Roman Conquest"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-2.3, ymax=2.8, fill="grey90", alpha=0.3)+#
geom_text(aes(x=376, y=.0016, label="Visigothic Migration"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-2.3, ymax=2.8, fill="grey90", alpha=0.3)+#
geom_text(aes(x=550, y=.0016, label="Migration Period"))+#
geom_line(aes(1950-Age, Density), lwd=1.1) +#
geom_line(aes(1950-Age, Density), colour="light blue", lwd=0.5) +#
scale_x_continuous("Year BC/AD", limits = c(-350, 750)) +#
scale_y_continuous("Density", limits = c(0.0016, 0.0022)) +#
theme_light()
iberia.plot
iberia.plot <- ggplot(iberia.stack) +#
geom_text(aes(x=40, y=.002, label="Pax Romana"))+#
geom_text(aes(x=270, y=.00177, label="Imperial Crisis"))+#
geom_rect(aes(NULL, NULL), xmin=-43, xmax=-30, ymin=-2.3, ymax=2.8, fill="grey90", alpha=0.3)+#
geom_text(aes(x=-38, y=.0016, label="Roman Conquest"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-2.3, ymax=2.8, fill="grey90", alpha=0.3)+#
geom_text(aes(x=376, y=.0016, label="Visigothic Migration"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-2.3, ymax=2.8, fill="grey90", alpha=0.3)+#
geom_text(aes(x=550, y=.0016, label="Migration Period"))+#
geom_line(aes(1950-Age, Density), lwd=1.1) +#
geom_line(aes(1950-Age, Density), colour="light blue", lwd=0.5) +#
scale_x_continuous("Year BC/AD", limits = c(-350, 750)) +#
scale_y_continuous("Density") +#
theme_light()
iberia.plot
iberia.plot <- ggplot(iberia.stack) +#
scale_x_continuous("Year BC/AD") +#
scale_y_continuous("Density") +#
theme_light()#
iberia.plot
iberia.plot <- ggplot(iberia.stack) +#
geom_line(aes(1950-Age, Density), lwd=1.1) +#
geom_line(aes(1950-Age, Density), colour="light blue", lwd=0.5) +#
scale_x_continuous("Year BC/AD") +#
scale_y_continuous("Density") +#
theme_light()
iberia.plot <- ggplot(iberia.stack) +#
scale_x_continuous("Year BC/AD") +#
scale_y_continuous("Density") +#
theme_light()#
iberia.plot
iberia.plot <- ggplot(iberia.stack) +#
geom_line(aes(1950-Age, Density), lwd=1.1) +#
geom_line(aes(1950-Age, Density), colour="light blue", lwd=0.5) +#
scale_x_continuous("Year BC/AD") +#
scale_y_continuous("Density") +#
theme_light()#
iberia.plot
iberia.plot <- ggplot(iberia.stack) +#
geom_line(aes(1950-Age, Density), lwd=1.1) +#
geom_line(aes(1950-Age, Density), colour="light blue", lwd=0.5) +#
scale_x_continuous("Year BC/AD") +#
scale_y_continuous("Density", limits=c(-8000, 2000)) +#
theme_light()#
iberia.plot
iberia.plot <- ggplot(iberia.stack) +#
geom_line(aes(1950-Age, Density), lwd=1.1) +#
geom_line(aes(1950-Age, Density), colour="light blue", lwd=0.5) +#
scale_x_continuous("Year BC/AD", limits=c(-8000, 2000)) +#
scale_y_continuous("Density") +#
theme_light()#
iberia.plot
head(ukdata)
uk.data <- read.csv(file="/Users/lee/Dropbox/Documents/GISP and Civilization/UK/Audited-Table 1.csv")#
#
ukdata <- collapse.the.dates.begin(sites=uk.data$C14_ID, region=uk.data$Type, dates=as.numeric(as.vector(uk.data$Date_BP)), sigma=as.numeric(as.vector(uk.data$Sigma)), lat=uk.data$OS_East, long=uk.data$OS_North, datemin = 100, datemax = 45000)#
uk.stack <- stack.14C(ukdata$X14C.year, ukdata$Sigma, xmin=0, xmax= 40000)
head(uk.stack)
uk.stack <- arrange(uk.Stack, Age)
uk.stack <- arrange(uk.stack, Age)
head(uk.stack)
uk.bcp <- bcp(uk.stack$Density, uk.stack$Age, burnin=2000, mcmc=10000)
uk.bcp.frame <- data.frame(1950-uk.stack$Age, uk.stack$Density, uk.bcp$posterior.mean, uk.bcp$posterior.prob, uk.bcp$posterior.var)#
colnames(uk.bcp.frame) <- c("Year", "NAO", "PosteriorMean", "PosteriorProb", "PosteriorVar")
head(uk.bcp.frame)
plot(uk.bcp)
uk.prob <- ggplot(uk.bcp.frame) +#
geom_rect(aes(NULL, NULL), xmin=-43, xmax=-30, ymin=-2.3, ymax=2.8, fill="grey90", alpha=0.3)+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-2.3, ymax=2.8, fill="grey90", alpha=0.3)+#
geom_text(aes(x=376, y=.0016, label="Visigothic Migration"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-2.3, ymax=2.8, fill="grey90", alpha=0.3)+#
geom_line(aes(Year, PosteriorProb), lwd=1.1) +#
geom_line(aes(Year, PosteriorProb), colour="light blue", lwd=0.5) +#
scale_x_continuous("Year BC/AD", limits = c(-350, 750)) +#
scale_y_continuous("Posterior Probability") +#
theme_light()
uk.prob
library(shiny)
runApp("~/Desktop/aes-app")
###Copy and paste this script into the R console on your computer. It will be compatible with Windows, Mac, and Linux. #
#
###All sentences beginning with "###" will be invisible to the software, and will caption and describe each step of the analysis and figures for [CITATION]#
#
###Erase everything that comes before#
rm(list = ls(all = TRUE))#
#
###Compatibility#
if(.Platform$OS.type=="windows") {#
  quartz<-function() windows()#
}#
#
###IMPORTANT NOTE: R uses packages to facilitate the analysis of data and production of figures. If you do not have the TTR, bcp, or ggplot2 packages installed, the following three lines of text will do it for you - all you have to do is delete the "###" that precedes the commands#
#
###The command below will bring up a list of download sites. Pick one closest to you to speed up the download process#
###chooseCRANmirror()#
#
###The script below will then install the TTR package (for moving averages), bcp package (for Bayesian Change-Point analysis), and ggplot2 (for generating data plots)#
###Note: Installation of packages may take up to an hour, depending upon the speed of your internect connection. #
###install.packages("TTR", dependencies = TRUE)#
###install.packages("bcp", dependencies = TRUE)#
###install.packages("ggplot2", dependencies = TRUE)#
#
###Activate the packages#
#
library(ggplot2)#
library(gridExtra)#
library(rgl)#
library(fpc)#
library(cluster)#
library(siar)#
library(vcd)
raw <- read.csv(file="~/Dropbox/Documents/XRF-UNM-Stanford/Tokyo Test Results/Belize Total K0732/Total-Table 1.csv")
ls(raw)
attach(raw)
sr.zr <- SrKa1/ZrKa1
sr.zr <- Sr.Ka1/Zr.Ka1
rb.zr <- Rb.Ka1/Zr.Ka1
qplot(rb.zr, sr.zr, geom=point) + theme_light()
qplot(rb.zr, sr.zr, geom=points) + theme_light()
qplot(rb.zr, sr.zr, geom="point") + theme_light()
plot3d(x= Rb.Ka1, y= Zr.Ka1, z= Sr.Ka1, zlab="SrKa1", ylab="ZrKa1", xlab="RbKa1", type="s",  size=100, radius=100, box=F)
plot3d(x= Rb.Ka1/ZrKa1, y= Sr/Ka1Zr.Ka1, z= Mn.Ka1/Fe.Ka1, zlab="SrKa1", ylab="ZrKa1", xlab="RbKa1", type="s",  size=100, radius=100, box=F)
plot3d(x= Rb.Ka1/ZrKa1, y= Sr.Ka1/Zr.Ka1, z= Mn.Ka1/Fe.Ka1, zlab="Mn/Fe", ylab="Sr/Zr", xlab="Rb/Zr", type="s",  size=100, radius=100, box=F)
plot3d(x= Rb.Ka1/Zr.Ka1, y= Sr.Ka1/Zr.Ka1, z= Mn.Ka1/Fe.Ka1, zlab="Mn/Fe", ylab="Sr/Zr", xlab="Rb/Zr", type="s",  size=100, radius=100, box=F)
plot3d(x= Rb.Ka1/Zr.Ka1, y= Sr.Ka1/Zr.Ka1, z= Mn.Ka1/Fe.Ka1, zlab="Mn/Fe", ylab="Sr/Zr", xlab="Rb/Zr", type="s",  size=3, radius=3, box=F)
plot3d(x= Rb.Ka1/Zr.Ka1, y= Sr.Ka1/Zr.Ka1, z= Mn.Ka1/Fe.Ka1, zlab="Mn/Fe", ylab="Sr/Zr", xlab="Rb/Zr", type="s", box=F)
plot3d(x= Rb.Ka1/Zr.Ka1, y= Sr.Ka1/Zr.Ka1, z= Mn.Ka1/Fe.Ka1, zlab="Mn/Fe", ylab="Sr/Zr", xlab="Rb/Zr", type="s",  size=.3, radius=.3, box=F)
plot3d(x= Rb.Ka1/Zr.Ka1, y= Sr.Ka1/Zr.Ka1, z= Mn.Ka1/Fe.Ka1, zlab="Mn/Fe", ylab="Sr/Zr", xlab="Rb/Zr", type="s",  size=.03, radius=.03, box=F)
plot3d(x= Rb.Ka1/Zr.Ka1, y= Sr.Ka1/Zr.Ka1, z= Mn.Ka1/Fe.Ka1, zlab="Mn/Fe", ylab="Sr/Zr", xlab="Rb/Zr", type="s",  size=.003, radius=.003, box=F)
plot3d(x= Rb.Ka1/Zr.Ka1, y= Sr.Ka1/Zr.Ka1, z= Mn.Ka1/Fe.Ka1, zlab="Mn/Fe", ylab="Sr/Zr", xlab="Rb/Zr", type="s",  size=.009, radius=.009, box=F)
plot3d(x= Rb.Ka1/Zr.Ka1, y= Sr.Ka1/Zr.Ka1, z= Y.Ka1/Zr.Ka1, zlab="Y/Zr", ylab="Sr/Zr", xlab="Rb/Zr", type="s",  size=.009, radius=.009, box=F)
###Load Packages#
library(TTR)#
library(ggplot2)#
library(gridExtra)#
library(scales)#
library(gtable)#
library(wq)#
library(Bchron)#
library(plyr)#
library(bcp)#
#library(mgcv)#
library(reshape2)#
library(pbapply)#
library(xlsx)#
library(data.table)#
library(dplyr)#
library(akima)#
library(ggmap)#
library(ggthemes)#
library(bcp)
Eu <- get_map(location="europe", zoom=3, maptype="terrain")
library(shiny)
#Erase everything that comes before#
rm(list = ls(all = TRUE))#
#
#Compatibility#
if(.Platform$OS.type=="windows") {#
    quartz<-function() windows()#
}#
###Load Packages#
library(TTR)#
library(ggplot2)#
library(gridExtra)#
library(scales)#
library(gtable)#
library(wq)#
library(Bchron)#
library(plyr)#
library(bcp)#
#library(mgcv)#
library(reshape2)#
library(pbapply)#
library(xlsx)#
library(data.table)#
library(dplyr)#
library(akima)#
library(ggmap)#
library(ggthemes)#
library(bcp)#
library(rgdal)#
library(ncdf4)#
library(date)#
library(RNetCDF)#
library(rasterVis)#
library(mapmate)#
####################################################
#######Calibration & Confidence Band Function#######
####################################################
####Function to organize plots in a window#
layOut = function(...) {#
    require(grid)#
    x <- list(...)#
    n <- max(sapply(x, function(x) max(x[[2]])))#
    p <- max(sapply(x, function(x) max(x[[3]])))#
    pushViewport(viewport(layout = grid.layout(n, p)))#
    for (i in seq_len(length(x))) {#
        print(x[[i]][[1]], vp = viewport(layout.pos.row = x[[i]][[2]],#
        layout.pos.col = x[[i]][[3]]))#
    }#
}#
#####Collapse Dates#
collapse.the.dates.begin <- function(sites, biogeo, general, dates, sigma) {#
    n.t <- rep(100, length(sites))#
    df <- data.frame(sites, biogeo, general, dates, sigma)#
    colnames(df) <- c("Site", "Biogeo_Uni", "St_Area_NE", "CYrBPunc", "Sigma")#
    df <- arrange(df, desc(CYrBPunc))#
    df <- arrange(df, desc(Site))#
    df <- arrange(df, desc(Biogeo_Uni))#
    df <- arrange(df, desc(St_Area_NE))#
    df$Ttest <- c(#
    (abs(df[1:(nrow(df)-1),4]-df[2:nrow(df), 4]))/((sqrt(df[2:nrow(df), 5]^2 + df[1:(nrow(df)-1),5]^2)*sqrt(1/100))), NA)#
    df$pvalue <- c((2*pt(df[1:nrow(df),6], 100, lower=FALSE)))#
    df$Collapse <- rep("No", length(sites))#
    df <- transform(df, Collapse = ifelse(pvalue > 0.05, "Yes", Collapse))#
    df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
    df <- as.data.frame(df)#
    df <- df[complete.cases(df),]#
    return(df)#
}#
#
collapse.the.dates.taxa <- function(sites, biogeo, general, dates, sigma, taxa) {#
    n.t <- rep(100, length(sites))#
    df <- data.frame(sites, biogeo, general, dates, sigma)#
    colnames(df) <- c("Site", "Biogeo_Uni", "St_Area_NE", "CYrBPunc", "Sigma", "Taxa")#
    df <- arrange(df, desc(CYrBPunc))#
    df <- arrange(df, desc(Site))#
    df <- arrange(df, desc(Biogeo_Uni))#
    df <- arrange(df, desc(St_Area_NE))#
    df$Ttest <- c(#
    (abs(df[1:(nrow(df)-1),4]-df[2:nrow(df), 4]))/((sqrt(df[2:nrow(df), 5]^2 + df[1:(nrow(df)-1),5]^2)*sqrt(1/100))), NA)#
    df$pvalue <- c((2*pt(df[1:nrow(df),6], 100, lower=FALSE)))#
    df$Collapse <- rep("No", length(sites))#
    df <- transform(df, Collapse = ifelse(pvalue > 0.05, "Yes", Collapse))#
    df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
    df <- as.data.frame(df)#
    df <- df[complete.cases(df),]#
    return(df)#
}#
####Function to organize plots in a window#
layOut = function(...) {#
    require(grid)#
    x <- list(...)#
    n <- max(sapply(x, function(x) max(x[[2]])))#
    p <- max(sapply(x, function(x) max(x[[3]])))#
    pushViewport(viewport(layout = grid.layout(n, p)))#
    for (i in seq_len(length(x))) {#
        print(x[[i]][[1]], vp = viewport(layout.pos.row = x[[i]][[2]],#
        layout.pos.col = x[[i]][[3]]))#
    }#
}#
#
####Function to maintain significant digits in plot#
fmt <- function(){#
    function(x) format(x,nsmall = 2,scientific = FALSE)#
}#
####################################################
#######Calibration & Confidence Band Function#######
####################################################
#
###Multicore apply function with status bar#
mcpblapply <- function (X, FUN, ..., mc.preschedule = TRUE, mc.set.seed = TRUE,#
mc.silent = FALSE, mc.cores = getOption("mc.cores", 2L),#
mc.cleanup = TRUE, mc.allow.recursive = TRUE, USE.NAMES = TRUE, simplify = TRUE)#
{#
    FUN <- match.fun(FUN)#
    if (!is.vector(X) || is.object(X))#
    X <- as.list(X)#
    B <- length(X)#
    if (!(interactive() && dopb() && B >= 1))#
    return(mclapply(X, FUN, ...#
    ))#
    pb <- startpb(0, B)#
    rval <- vector("list", B)#
    for (i in 1:B) {#
        rval[i] <- list(FUN(X[[i]], ...))#
        setpb(pb, i)#
    }#
    close(pb)#
    names(rval) <- names(X)#
    rval#
}#
#
mcpbsapply <- function (X, FUN, ..., mc.preschedule = TRUE, mc.set.seed = TRUE,#
mc.silent = FALSE, mc.cores = getOption("mc.cores", 2L),#
mc.cleanup = TRUE, mc.allow.recursive = TRUE, USE.NAMES = TRUE, simplify = TRUE)#
{#
    FUN <- match.fun(FUN)#
    answer <- mcpblapply(X = X, FUN = FUN,  ..., USE.NAMES = TRUE)#
    if (USE.NAMES && is.character(X) && is.null(names(answer)))#
    names(answer) <- X#
    if (!identical(simplify, FALSE) && length(answer))#
    simplify2array(answer, higher = (simplify == "array"))#
    else answer#
}#
#
mcreplicate <- function(n, expr, simplify = "array", mc.cores = getOption("mc.cores", 2L)) {#
    mcpbsapply(integer(n), eval.parent(substitute(function(...) expr)), mc.cores = getOption("mc.cores", 2L),#
    simplify = simplify)#
}#
conf.loess <- function(x, sigma, n, reps, xmin, xmax) {#
    samp.intcal <- rep("intcal13", length(x))#
    samp.slugdens <- BchronCalibrate(x, sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    res.by <- by(samp.ages$ageGrid, samp.ages$.id, median)#
    res.t <- t(res.by)#
    samp.age.grid <- c(samp.ages$ageGrid, xmin, xmax)#
    time <- seq(xmin+5, xmax-5, 10)#
    samp.grid <- sort(samp.age.grid, decreasing=TRUE)#
    samp.grid <- samp.grid[samp.grid < xmax & samp.grid > xmin]#
    samp.hist <- hist(samp.grid, breaks=length(time))#
    samp.hist <- data.frame(time, samp.hist$counts, samp.hist$counts/sum(samp.hist$counts))#
    colnames(samp.hist) <- c("Age", "Counts", "Density")#
    #samp.hist <- arrange(samp.all, desc(Age))#
    makeloess <- function(x, n){#
        time <- seq(xmin+5, xmax-5, 10)#
        samp.age <- sample(x, size=n, replace=TRUE)#
        samp.dist <- sapply(1:n, function(x) rnorm(500, samp.age, 85))#
        samp.dist <- as.vector(samp.dist)#
        samp.dist <- c(xmax, xmin, samp.dist)#
        samp.date <- tapply(samp.dist, cut(samp.dist, length(time)), length)#
        samp.loess <- lowess(time, samp.date, f=0.15)#
        samp.fitted <- samp.loess$y#
        return(samp.fitted)#
    }#
    samp.replicate <- (replicate(reps, makeloess(res.t, n)))#
    samp.replicate <- as.data.frame(samp.replicate)#
    samp.replicate[is.na(samp.replicate)] <- 0#
    samp.replicate <- sweep(samp.replicate,2,colSums(samp.replicate),`/`)#
    samp.results.replicate <- transform(samp.replicate, MEAN=apply(samp.replicate,1, mean, na.rm = TRUE))#
    samp.results.replicate <- transform(samp.results.replicate, SD=apply(samp.results.replicate,1, sd, na.rm = TRUE))#
    samp.descriptive <- data.frame(time, samp.results.replicate$MEAN, samp.results.replicate$SD)#
    colnames(samp.descriptive) <- c("Age", "Mean", "SD")#
    #samp.descriptive <- arrange(samp.descriptive, desc(Age))#
    samp.all <- data.frame(time, samp.hist$Density, samp.hist$Counts, samp.descriptive$Mean, samp.descriptive$SD, samp.replicate)#
    names(samp.all)[names(samp.all)=="time"] <- "Age"#
    names(samp.all)[names(samp.all)=="samp.descriptive.Mean"] <- "Mean"#
    names(samp.all)[names(samp.all)=="samp.descriptive.SD"] <- "SD"#
    names(samp.all)[names(samp.all)=="samp.hist.Density"] <- "Density"#
    names(samp.all)[names(samp.all)=="samp.hist.Counts"] <- "Counts"#
    samp.all <- arrange(samp.all, desc(Age))#
    return(samp.all)#
}#
taphonomic.correct <- function(stack.14C.data) {#
    df <- stack.14C.data#
    n.t <- 5.726442*(10^6)*(df$Age + 2176.4)^-1.3925309#
    lambda <- 1.3925309/(2176.4+df$Age)*100#
    lambda.r <- 1-lambda#
    n.t.relative <- n.t/128.8192#
    df$Counts.Corrected <-df$Counts/n.t.relative#
    count.mod.sum <- sum(df$Counts.Corrected)#
    df$Density.Corrected <- df$Counts.Corrected/count.mod.sum#
    return(df)#
}#
#
stack.14C.4D <- function(date, sigma, xmin, xmax, lat, long){#
    date <- c(date, 100)#
    sigma <- c(sigma, 50)#
    lat <- c(lat, 0)#
    long <- c(long, 0)#
    date.frame <- data.frame(date, sigma, lat, long)#
    names(date.frame) <- c("Date", "Sigma", "Lat", "Long")#
    date.frame <- date.frame[complete.cases(date.frame),]#
    date.sub <- subset(date.frame, (xmin-500) < Date & Date < (xmax + 500))#
    ids.cus = paste("date", 1:length(date.sub$Date), sep = "")#
    coord.sub <- data.frame(ids.cus, date.sub$Lat, date.sub$Long)#
    names(coord.sub) <- c(".id", "Lat", "Long")#
    samp.intcal <- rep("intcal13", length(date.sub$Date))#
    samp.slugdens <- BchronCalibrate(date.sub$Date, date.sub$Sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.mean <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, mean))#
    samp.sd <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, sd))#
    samp.frame <- data.frame(samp.mean, samp.sd)#
    colnames(samp.frame) <- c("Mean", "Sd")#
    samp.frame$Min <- samp.frame$Mean-date.sub$Sigma#
    samp.frame$Max <- samp.frame$Mean+date.sub$Sigma#
    samp.frame$Lat <- coord.sub$Lat#
    samp.frame$Long <- coord.sub$Long#
    samp.frame <- data.table(samp.frame)#
    lat.frame <- samp.frame[, list(Lat=Lat, ageGrid = seq(from=trunc(Min), to=trunc(Max))), by = 1:nrow(samp.frame)]#
    long.frame <- samp.frame[, list(Long=Long, ageGrid = seq(from=trunc(Min), to=trunc(Max))), by = 1:nrow(samp.frame)]#
    fin.frame <- data.frame(lat.frame$Lat, long.frame$Long, lat.frame$ageGrid)#
    colnames(fin.frame) <- c("Lat", "Long", "ageGrid")#
    return(fin.frame)#
}#
#######
stack.14C <- function(x, sigma, xmin, xmax, taxa){#
    samp.intcal <- rep("intcal13", length(x))#
    samp.slugdens <- BchronCalibrate(x, sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    fill <- seq(xmin, xmax, 1)#
    samp.age.grid <- c(samp.ages$ageGrid, fill)#
    samp.grid <- sort(samp.age.grid, decreasing=TRUE)#
    samp.grid <- samp.grid[samp.grid < xmax & samp.grid > xmin]#
    time <- seq(xmin+5, xmax-5, 10)#
    samp.hist <- hist(samp.grid, breaks=length(time))#
    samp.hist <- data.frame(time, samp.hist$counts, samp.hist$counts/sum(samp.hist$counts))#
    colnames(samp.hist) <- c("Age", "Counts", "Density")#
    corrected.samp.hist <- taphonomic.correct(samp.hist)#
    return(corrected.samp.hist)#
}#
stack.14C.taxa <- function(date, sigma, xmin, xmax, lat, long, taxa){#
    date <- as.numeric(as.vector(c(date, 49000)))#
    sigma <- as.numeric(as.vector(c(sigma, 4900)))#
    lat <- c(lat, 0)#
    long <- c(long, 0)#
    taxa <- as.vector(c(taxa, "blank"))#
    date.frame <- data.frame(date, sigma, lat, long, taxa)#
    names(date.frame) <- c("Date", "Sigma", "Lat", "Long", "Taxa")#
    date.frame <- date.frame[complete.cases(date.frame),]#
    date.sub <- subset(date.frame, (xmin) < Date & Date < (xmax))#
    ids.cus = paste("date", 1:length(date.sub$Date), sep = "")#
    coord.sub <- data.frame(ids.cus, date.sub$Lat, date.sub$Long, date.sub$Taxa)#
    names(coord.sub) <- c(".id", "Lat", "Long", "Taxa")#
    samp.intcal <- rep("intcal13", length(date.sub$Date))#
    samp.slugdens <- BchronCalibrate(date.sub$Date, date.sub$Sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.mean <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, mean))#
    samp.sd <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, sd))#
    samp.frame <- data.frame(samp.mean, samp.sd)#
    colnames(samp.frame) <- c("Mean", "Sd")#
    samp.frame$Min <- samp.frame$Mean-date.sub$Sigma#
    samp.frame$Max <- samp.frame$Mean+date.sub$Sigma#
    samp.frame$Lat <- coord.sub$Lat#
    samp.frame$Long <- coord.sub$Long#
    samp.frame$Taxa <- coord.sub$Taxa#
    samp.frame <- data.table(samp.frame)#
    lat.frame <- samp.frame[, list(Lat=Lat, ageGrid = seq(from=trunc(Min), to=trunc(Max))), by = 1:nrow(samp.frame)]#
    long.frame <- samp.frame[, list(Long=Long, ageGrid = seq(from=trunc(Min), to=trunc(Max))), by = 1:nrow(samp.frame)]#
    taxa.frame <- samp.frame[, list(Taxa=Taxa, ageGrid = seq(from=trunc(Min), to=trunc(Max))), by = 1:nrow(samp.frame)]#
    fin.frame <- data.frame(taxa.frame$Taxa, lat.frame$Lat, long.frame$Long, lat.frame$ageGrid)#
    colnames(fin.frame) <- c("Taxa", "Lat", "Long", "ageGrid")#
    return(fin.frame)#
}#
#
taxa.data <- function(stack.14C.taxa.object, taxa.names, xmin, xmax) {#
    temp.df.1 <- subset(stack.14C.taxa.object, stack.14C.taxa.object$Taxa==taxa.names)#
    temp.df <- data.frame(temp.df.1$ageGrid, factor(temp.df.1$Taxa))#
    colnames(temp.df) <- c("ageGrid", "Taxa")#
    temp.list <- split(temp.df$ageGrid, f=temp.df$Taxa)#
    temp.list <- rapply(temp.list, f=sort, how="list", decreasing=TRUE)#
    time <- seq(xmin+5, xmax-5, 10)#
    samp.hist.list <- rapply(temp.list, f=hist, how="list", breaks=length(time))#
    samp.mids <- sapply(samp.hist.list, "[[", 4)#
    samp.counts <- sapply(samp.hist.list, "[[", 2)#
    samp.density <- sapply(samp.hist.list, "[[", 3)#
    samp.mids.df <- ldply(samp.mids, data.frame)#
    samp.counts.df <- ldply(samp.counts, data.frame)#
    samp.density.df <- ldply(samp.density, data.frame)#
    samp.hist <- data.frame(samp.mids.df[1], samp.mids.df[2], samp.counts.df[2], samp.density.df[2])#
    colnames(samp.hist) <- c("Taxa", "Age", "Counts", "Density")#
    corrected.samp.hist <- taphonomic.correct(samp.hist)#
    return(corrected.samp.hist)#
}#
#
taxa.data.single <- function(stack.14C.taxa.object, taxa.names, xmin, xmax) {#
    temp.df.1 <- subset(stack.14C.taxa.object, stack.14C.taxa.object$Taxa==taxa.names)#
    temp.df <- data.frame(temp.df.1$ageGrid, factor(temp.df.1$Taxa))#
    colnames(temp.df) <- c("ageGrid", "Taxa")#
    temp.list <- split(temp.df$ageGrid, f=temp.df$Taxa)#
    temp.list <- rapply(temp.list, f=sort, how="list", decreasing=TRUE)#
    time <- seq(xmin+5, xmax-5, 10)#
    samp.hist.list <- rapply(temp.list, f=hist, how="list", breaks=length(time))#
    samp.mids <- sapply(samp.hist.list, "[[", 4)#
    samp.counts <- sapply(samp.hist.list, "[[", 2)#
    samp.density <- sapply(samp.hist.list, "[[", 3)#
    samp.mids.df <- ldply(samp.mids, data.frame)#
    samp.counts.df <- ldply(samp.counts, data.frame)#
    samp.density.df <- ldply(samp.density, data.frame)#
    samp.hist <- data.frame(samp.mids.df[1], samp.counts.df[1], samp.density.df[1])#
    colnames(samp.hist) <- c("Age", "Counts", "Density")#
    corrected.samp.hist <- taphonomic.correct(samp.hist)#
    return(corrected.samp.hist)#
}#
median.stack.14C <- function(x, sigma, xmin, xmax){#
    samp.intcal <- rep("intcal13", length(x))#
    samp.slugdens <- BchronCalibrate(x, sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.median <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, median))#
    medians.all <-as.vector(samp.median[,1])#
    n <- length(medians.all)#
    medians <- medians.all[medians.all < xmax & medians.all > xmin]#
    return(medians)#
}#
######Function to Generate Confidence Bands around SCDRD#
conf.cal.loess <- function(dates, sigma, n, reps, sites, xmin, xmax, ..., cores = getOption("mc.cores", 2L), collapse.dates=FALSE) {#
    collapse.the.dates <- function(sites, dates, sigma) {#
        n.t <- rep(100, length(sites))#
        df <- data.frame(sites, dates, sigma)#
        colnames(df) <- c("Sites", "Date", "Sigma")#
        df <- arrange(df, desc(Date))#
        df <- arrange(df, desc(Sites))#
        df$Ttest <- c(#
        (abs(df[1:(nrow(df)-1),2]-df[2:nrow(df), 2]))/((sqrt(df[2:nrow(df), 3]^2 + df[1:(nrow(df)-1),3]^2)*sqrt(1/100))), NA)#
        df$pvalue <- c((2*pt(df[1:nrow(df),4], 100, lower=FALSE)))#
        df$Collapse <- rep("No", length(sites))#
        df <- transform(df, Collapse = ifelse(pvalue > 0.05, "Yes", Collapse))#
        df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
        df <- as.data.frame(df)#
        df <- df[complete.cases(df),]#
        return(df)#
    }#
    uncollapse.the.dates <- function(sites, dates, sigma) {#
        df <- data.frame(sites, dates, sigma)#
        colnames(df) <- c("Sites", "Date", "Sigma")#
        return(df)#
    }#
    date.data <- if(isTRUE(collapse.dates)){#
        collapse.the.dates(sites, dates, sigma)#
    } else {#
        uncollapse.the.dates(sites, dates, sigma)#
    }#
    samp.intcal <- rep("intcal13", length(date.data$Date))#
    samp.slugdens <- BchronCalibrate(date.data$Date, date.data$Sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.mean <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, mean))#
    samp.sd <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, sd))#
    samp.frame <- data.frame(samp.mean, samp.sd, samp.ages$.id)#
    colnames(samp.frame) <- c("Mean", "Sd", "Id")#
    samp.frame$Min <- samp.frame$Mean-date.sub$Sigma*2#
    samp.frame$Max <- samp.frame$Mean+date.sub$Sigma*2#
    id.frame <- samp.frame[, list(Id=Id, ageGrid = seq(from=trunc(Min), to=trunc(Max))), by = 1:nrow(samp.frame)]#
    colnames(id.frame) <- c("Id", "ageGrid")#
    res.by <- by(samp.frame$ageGrid, samp.frame$.id, median)#
    res.t <- t(res.by)#
    fill <- seq(xmin, xmax, 1)#
    samp.age.grid <- c(samp.frame$ageGrid, fill)#
    time <- seq(xmin+5, xmax-5, 10)#
    samp.grid <- sort(samp.age.grid, decreasing=TRUE)#
    samp.grid <- samp.grid[samp.grid < xmax & samp.grid > xmin]#
    samp.hist <- hist(samp.grid, breaks=length(time))#
    samp.hist <- data.frame(time, samp.hist$counts, samp.hist$counts/sum(samp.hist$counts))#
    colnames(samp.hist) <- c("Age", "Counts", "Density")#
    #samp.hist <- arrange(samp.all, desc(Age))#
    makeloess <- function(dates, n){#
        time <- seq(xmin+5, xmax-5, 10)#
        n.s <- length(dates)#
        samp.order <- sample(n.s, size=n, replace=TRUE)#
        samp.dist.n <- samp.slugdens[samp.order]#
        temp.ages <- ldply(samp.dist.n, data.frame)#
        temp.age.grid <- c(temp.ages$ageGrid, fill)#
        temp.grid <- temp.age.grid[temp.age.grid < xmax & samp.grid > xmin]#
        samp.dist <- c(fill, temp.grid)#
        samp.dist <- as.vector(samp.dist)#
        samp.dist <- c(xmax, xmin, samp.dist)#
        samp.date <- tapply(samp.dist, cut(samp.dist, length(time)), length)#
        samp.loess <- lowess(time, samp.date, f=0.15)#
        samp.fitted <- samp.loess$y#
        return(samp.fitted)#
    }#
    samp.replicate <- (mcreplicate(reps, makeloess(dates, n)))#
    samp.replicate.dat <- as.data.frame(samp.replicate)#
    samp.replicate.dat[is.na(samp.replicate.dat)] <- 0#
    samp.replicated <- sweep(samp.replicate.dat,2,colSums(samp.replicate.dat),`/`)#
    samp.results.replicated.m <- transform(samp.replicated, MEAN=apply(X=samp.replicated, MARGIN=1, FUN=mean, na.rm = TRUE))#
    samp.results.replicated.s <- transform(samp.replicated, SD=apply(X=samp.replicated, MARGIN=1, FUN=sd, na.rm = TRUE))#
    samp.descriptive <- data.frame(time, samp.results.replicated.m$MEAN, samp.results.replicated.s$SD)#
    colnames(samp.descriptive) <- c("Age", "Mean", "SD")#
    #samp.descriptive <- arrange(samp.descriptive, desc(Age))#
    samp.all <- data.frame(time, samp.hist$Density, samp.hist$Counts, samp.descriptive$Mean, samp.descriptive$SD)#
    names(samp.all)[names(samp.all)=="time"] <- "Age"#
    names(samp.all)[names(samp.all)=="samp.descriptive.Mean"] <- "Mean"#
    names(samp.all)[names(samp.all)=="samp.descriptive.SD"] <- "SD"#
    names(samp.all)[names(samp.all)=="samp.hist.Density"] <- "Density"#
    names(samp.all)[names(samp.all)=="samp.hist.Counts"] <- "Counts"#
    samp.all <- arrange(samp.all, desc(Age))#
    return(samp.all)#
}#
######Function to Generate Confidence Bands around SCDRD#
conf.cal.loess.bad <- function(dates, sigma, n, reps, sites, xmin, xmax, ..., cores = getOption("mc.cores", 2L), collapse.dates=FALSE) {#
    collapse.the.dates <- function(sites, dates, sigma) {#
        n.t <- rep(100, length(sites))#
        df <- data.frame(sites, dates, sigma)#
        colnames(df) <- c("Sites", "Date", "Sigma")#
        df <- arrange(df, desc(Date))#
        df <- arrange(df, desc(Sites))#
        df$Ttest <- c(#
        (abs(df[1:(nrow(df)-1),2]-df[2:nrow(df), 2]))/((sqrt(df[2:nrow(df), 3]^2 + df[1:(nrow(df)-1),3]^2)*sqrt(1/100))), NA)#
        df$pvalue <- c((2*pt(df[1:nrow(df),4], 100, lower=FALSE)))#
        df$Collapse <- rep("No", length(sites))#
        df <- transform(df, Collapse = ifelse(pvalue > 0.05, "Yes", Collapse))#
        df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
        df <- as.data.frame(df)#
        df <- df[complete.cases(df),]#
        return(df)#
    }#
    uncollapse.the.dates <- function(sites, dates, sigma) {#
        df <- data.frame(sites, dates, sigma)#
        colnames(df) <- c("Sites", "Date", "Sigma")#
        return(df)#
    }#
    date.data <- if(isTRUE(collapse.dates)){#
        collapse.the.dates(sites, dates, sigma)#
    } else {#
        uncollapse.the.dates(sites, dates, sigma)#
    }#
    samp.intcal <- rep("intcal13", length(date.data$Date))#
    samp.slugdens <- BchronCalibrate(date.data$Date, date.data$Sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.mean <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, mean))#
    samp.sd <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, sd))#
    samp.frame <- data.frame(samp.mean, samp.sd, samp.ages$.id)#
    colnames(samp.frame) <- c("Mean", "Sd", "Id")#
    samp.frame$Min <- samp.frame$Mean-date.sub$Sigma*2#
    samp.frame$Max <- samp.frame$Mean+date.sub$Sigma*2#
    id.frame <- samp.frame[, list(Id=Id, ageGrid = seq(from=trunc(Min), to=trunc(Max))), by = 1:nrow(samp.frame)]#
    colnames(id.frame) <- c("Id", "ageGrid")#
    res.by <- by(samp.frame$ageGrid, samp.frame$.id, median)#
    res.t <- t(res.by)#
    fill <- seq(xmin, xmax, 1)#
    samp.age.grid <- c(samp.frame$ageGrid, fill)#
    time <- seq(xmin+5, xmax-5, 10)#
    samp.grid <- sort(samp.age.grid, decreasing=TRUE)#
    samp.grid <- samp.grid[samp.grid < xmax & samp.grid > xmin]#
    samp.hist <- hist(samp.grid, breaks=length(time))#
    samp.hist <- data.frame(time, samp.hist$counts, samp.hist$counts/sum(samp.hist$counts))#
    colnames(samp.hist) <- c("Age", "Counts", "Density")#
    #samp.hist <- arrange(samp.all, desc(Age))#
    makeloess <- function(dates, n){#
        time <- seq(xmin+5, xmax-5, 10)#
        n.s <- length(dates)#
        samp.order <- sample(n.s, size=n, replace=TRUE)#
        samp.dist.n <- samp.slugdens[samp.order]#
        temp.ages <- ldply(samp.dist.n, data.frame)#
        temp.age.grid <- c(temp.ages$ageGrid, fill)#
        temp.grid <- temp.age.grid[temp.age.grid < xmax & samp.grid > xmin]#
        samp.dist <- c(fill, temp.grid)#
        samp.dist <- as.vector(samp.dist)#
        samp.dist <- c(xmax, xmin, samp.dist)#
        samp.date <- tapply(samp.dist, cut(samp.dist, length(time)), length)#
        samp.loess <- lowess(time, samp.date, f=0.15)#
        samp.fitted <- samp.loess$y#
        return(samp.fitted)#
    }#
    samp.replicate <- (mcreplicate(reps, makeloess(dates, n)))#
    samp.replicate.dat <- as.data.frame(samp.replicate)#
    samp.replicate.dat[is.na(samp.replicate.dat)] <- 0#
    samp.replicated <- sweep(samp.replicate.dat,2,colSums(samp.replicate.dat),`/`)#
    samp.results.replicated.m <- transform(samp.replicated, MEAN=apply(X=samp.replicated, MARGIN=1, FUN=mean, na.rm = TRUE))#
    samp.results.replicated.s <- transform(samp.replicated, SD=apply(X=samp.replicated, MARGIN=1, FUN=sd, na.rm = TRUE))#
    samp.descriptive <- data.frame(time, samp.results.replicated.m$MEAN, samp.results.replicated.s$SD)#
    colnames(samp.descriptive) <- c("Age", "Mean", "SD")#
    #samp.descriptive <- arrange(samp.descriptive, desc(Age))#
    samp.all <- data.frame(time, samp.hist$Density, samp.hist$Counts, samp.descriptive$Mean, samp.descriptive$SD)#
    names(samp.all)[names(samp.all)=="time"] <- "Age"#
    names(samp.all)[names(samp.all)=="samp.descriptive.Mean"] <- "Mean"#
    names(samp.all)[names(samp.all)=="samp.descriptive.SD"] <- "SD"#
    names(samp.all)[names(samp.all)=="samp.hist.Density"] <- "Density"#
    names(samp.all)[names(samp.all)=="samp.hist.Counts"] <- "Counts"#
    samp.all <- arrange(samp.all, desc(Age))#
    return(samp.all)#
}#
#
###Traditional SCDPD#
BchronDensityCollapse <- function (dates, sigma, sites,  dfs = rep(100, length(dates)), numMix = 30,#
iterations = 10000, burn = 2000, thin = 8, updateAges = FALSE, collapse.dates=FALSE)#
{#
    collapse.the.dates <- function(sites, dates, sigma) {#
        n.t <- rep(100, length(sites))#
        df <- data.frame(sites, dates, sigma)#
        colnames(df) <- c("Sites", "Date", "Sigma")#
        df <- arrange(df, desc(Date))#
        df <- arrange(df, desc(Sites))#
        df$Ttest <- c(#
        (abs(df[1:(nrow(df)-1),2]-df[2:nrow(df), 2]))/((sqrt(df[2:nrow(df), 3]^2 + df[1:(nrow(df)-1),3]^2)*sqrt(1/100))), NA)#
        df$pvalue <- c((2*pt(df[1:nrow(df),4], 100, lower=FALSE)))#
        df$Collapse <- rep("No", length(sites))#
        df <- transform(df, Collapse = ifelse(pvalue > 0.05, "Yes", Collapse))#
        df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
        return(df)#
    }#
    uncollapse.the.dates <- function(sites, dates, sigma) {#
        df <- data.frame(sites, dates, sigma)#
        colnames(df) <- c("Sites", "Date", "Sigma")#
        return(df)#
    }#
    date.data <- if(isTRUE(collapse.dates)){#
        collapse.the.dates(sites, dates, sigma)#
    } else {#
        uncollapse.the.dates(sites, dates, sigma)#
    }#
    pathToCalCurves = system.file("data",#
    package = "Bchron")#
    calCurves <- rep("intcal13", length(date.data$Date))#
    ages <- date.data$Date#
    ageSds <- date.data$Sigma#
    if (length(ages) != length(ageSds))#
    stop("ages and 1-sigma errors must be same length")#
    if (length(ages) != length(calCurves))#
    stop("ages and Calibration curves must be same length")#
    x = BchronCalibrate(ages = ages, ageSds = ageSds, calCurves = calCurves,#
    pathToCalCurves = pathToCalCurves, eps = 0, dfs = rep(100,#
    length(ages)))#
    xSmall = BchronCalibrate(ages = ages, ageSds = ageSds, calCurves = calCurves,#
    pathToCalCurves = pathToCalCurves, dfs = rep(100, length(ages)))#
    n = length(x)#
    thetaRange = range(xSmall[[1]]$ageGrid)#
    for (i in 2:n) thetaRange = range(c(thetaRange, xSmall[[i]]$ageGrid))#
    offset = vector(length = n)#
    for (i in 1:n) {#
        offset[i] = ifelse(x[[i]]$calCurve == "normal", 61, 0)#
    }#
    gauss <- function(x, mu, sig) {#
        u <- (x - mu)/sig#
        y <- exp(-u * u/2)#
        y#
    }#
    gbase <- function(x, mus) {#
        sig <- (mus[2] - mus[1])/2#
        G <- outer(x, mus, gauss, sig)#
        G#
    }#
    clrInv = function(phi) {#
        return(exp(phi)/sum(exp(phi)))#
    }#
    J = numMix#
    mu = seq(thetaRange[1], thetaRange[2], length = numMix)#
    theta = vector(length = n)#
    for (j in 1:n) theta[j] = round(stats::rnorm(1, mean = x[[j]]$ageGrid[match(max(x[[j]]$densities),#
    x[[j]]$densities)], sd = ageSds[j]), 3)#
    phi = c(stats::runif(J - 1, -10, 10), 0)#
    p = as.numeric(clrInv(phi))#
    G = gbase(theta, mu)#
    remaining = (iterations - burn)/thin#
    thetaStore = matrix(ncol = length(theta), nrow = remaining)#
    pStore = matrix(ncol = J, nrow = remaining)#
    thetaAll = matrix(NA, ncol = n, nrow = iterations)#
    for (j in 1:n) thetaAll[, j] = sample(xSmall[[j]]$ageGrid,#
    size = iterations, prob = xSmall[[j]]$densities, replace = TRUE)#
    mu2 = mu#
    sigma2 = (mu[2] - mu[1])/2#
    my_dnorm = function(x) stats::dnorm(x, mean = mu2, sd = sigma2)#
    pb = utils::txtProgressBar(min = 1, max = iterations, style = 3,#
    width = 60, title = "Running BchronDensity")#
    for (i in 1:iterations) {#
        utils::setTxtProgressBar(pb, i)#
        if (i > burn & i%%thin == 0) {#
            ind = (i - burn)/thin#
            thetaStore[ind, ] = theta#
            pStore[ind, ] = p#
        }#
        if (updateAges) {#
            for (j in 1:n) {#
                thetaNew = round(stats::rnorm(1, theta[j], 0.5),#
                3)#
                thetaNewMatch = as.integer(thetaNew + offset[j]) +#
                1#
                thetaNewLogDens = max(log(x[[j]]$densities[thetaNewMatch]),#
                -1e+06)#
                priorNew.dens = sum(p * stats::dnorm(thetaNew,#
                mean = mu2, sd = sigma2))#
                thetaMatch = as.integer(theta[j] + offset[j]) +#
                1#
                thetaLogDens = max(log(x[[j]]$densities[thetaMatch]),#
                -1e+06)#
                priorDens = sum(p * stats::dnorm(theta[j], mean = mu2,#
                sd = sigma2))#
                logRtheta = thetaNewLogDens - thetaLogDens +#
                log(priorNew.dens) - log(priorDens)#
                if (stats::runif(1) < exp(logRtheta))#
                theta[j] = thetaNew#
            }#
        }#
        else {#
            theta = thetaAll[i, ]#
        }#
        for (j in 1:(J - 1)) {#
            phiNew = stats::rnorm(1, phi[j], 1)#
            phiAllNew = phi#
            phiAllNew[j] = phiNew#
            pNew = as.numeric(clrInv(phiAllNew))#
            phiNewLogDens = sum(log(G %*% pNew))#
            phiLogDens = sum(log(G %*% p))#
            logRphi = phiNewLogDens - phiLogDens + stats::dunif(phiNew,#
            -10, 10, log = TRUE) - stats::dunif(phi[j], -10,#
            10, log = TRUE)#
            if (stats::runif(1) < exp(logRphi)) {#
                phi[j] = phiNew#
                p = as.numeric(clrInv(phi))#
            }#
        }#
    }#
    output = list(theta = thetaStore, p = pStore, mu = mu, calAges = xSmall,#
    G = G)#
    class(output) = "BchronDensityRun"#
    return(output)#
}#
#
###Function to modify existing SCDPD from BchronDensity (modified from Bchron)#
SlugDens.t <- function (x, xmin, xmax)#
{#
    n = length(x$calAges)#
    thetaRange = range(x$calAges[[1]]$ageGrid)#
    for (i in 2:n) thetaRange = range(c(thetaRange, x$calAges[[i]]$ageGrid))#
    dateGrid = seq(xmin, xmax, length = 1000)#
    gauss <- function(x, mu, sig) {#
        u <- (x - mu)/sig#
        y <- exp(-u * u/2)#
        y#
    }#
    gbase <- function(x, mus) {#
        sig <- (mus[2] - mus[1])/2#
        G <- outer(x, mus, gauss, sig)#
        G#
    }#
    Gstar = gbase(dateGrid, x$mu)#
    dens = vector(length = length(dateGrid))#
    for (i in 1:nrow(x$p)) {#
        dens = dens + Gstar %*% x$p[i, ]#
    }#
    densFinal = dens/sum(dens)#
    slugbase <- data.frame(dateGrid,densFinal)#
    colnames(slugbase) <- c("Age", "Density")#
    slugbase <- arrange(slugbase, desc(Age))#
    return(slugbase)#
}#
#
SlugSig <- function(x, sigma, n, reps, xmin, xmax) {#
    time <- seq(xmin+5, xmax-5, 10)#
    samp.intcal <- rep("intcal13", length(x))#
    samp.slugdens <- BchronDensity(x, sigma, samp.intcal, numMix = 30, iterations=10000, burn=2000, thin=8, updateAges=FALSE)#
    samp.hist <- SlugDens.t(samp.slugdens, xmin, xmax)#
    makeloess <- function(x, n){#
        time <- seq(xmin+5, xmax-5, 10)#
        samp.14C <- sample(x, size=n, replace=TRUE)#
        samp.sig <- sample(sigma, size=n, replace=TRUE)#
        samp.dist.n <- BchronDensity(samp.14C, samp.sig, rep("intcal13", n), numMix = 30, iterations=10000, burn=2000, thin=8, updateAges=FALSE)#
        samp.dist <- SlugDens.t(samp.dist.n, xmin, xmax)#
        samp.loess <- lowess(samp.dist$Age, samp.dist$Density, f=0.15)#
        samp.fitted <- samp.loess$y#
        return(samp.fitted)#
    }#
    samp.replicate <- (pbreplicate(reps, makeloess(x, n)))#
    samp.replicate <- as.data.frame(samp.replicate)#
    samp.replicate[is.na(samp.replicate)] <- 0#
    samp.replicate <- sweep(samp.replicate,2,colSums(samp.replicate),`/`)#
    samp.results.replicate <- transform(samp.replicate, MEAN=apply(samp.replicate,1, mean, na.rm = TRUE))#
    samp.results.replicate <- transform(samp.results.replicate, SD=apply(samp.results.replicate,1, sd, na.rm = TRUE))#
    samp.descriptive <- data.frame(samp.hist$Age, samp.results.replicate$MEAN, samp.results.replicate$SD)#
    colnames(samp.descriptive) <- c("Age", "Mean", "SD")#
    #samp.descriptive <- arrange(samp.descriptive, desc(Age))#
    samp.all <- data.frame(samp.hist$Age, samp.hist$Density, samp.descriptive$Mean, samp.descriptive$SD, samp.replicate)#
    names(samp.all)[names(samp.all)=="samp.hist.Age"] <- "Age"#
    names(samp.all)[names(samp.all)=="samp.descriptive.Mean"] <- "Mean"#
    names(samp.all)[names(samp.all)=="samp.descriptive.SD"] <- "SD"#
    names(samp.all)[names(samp.all)=="samp.hist.Density"] <- "Density"#
    samp.all <- arrange(samp.all, desc(Age))#
    return(samp.all)#
}#
####Function to maintain significant digits in plot#
fmt <- function(){#
    function(x) format(x,nsmall = 4,scientific = FALSE)#
}#
collapse.the.dates.begin <- function(sites, region, taxa, dates, sigma, lat, long, datemin, datemax) {#
    n.t <- rep(100, length(sites))#
    df.1 <- data.frame(sites, region, dates, sigma, lat, long)#
    colnames(df.1) <- c("Site", "Region", "X14C.year", "Sigma", "Lat", "Long")#
    df <- subset(df.1, df.1$X14C.year < datemax & df.1$X14C.year > datemin)#
    df <- arrange(df, desc(X14C.year))#
    df <- arrange(df, desc(Site))#
    df <- arrange(df, desc(Region))#
    df$Ttest <- c(#
    (abs(df[1:(nrow(df)-1),3]-df[2:nrow(df), 3]))/((sqrt(df[2:nrow(df), 4]^2 + df[1:(nrow(df)-1),4]^2)*sqrt(1/100))), NA)#
    df$pvalue <- c((2*pt(df[1:nrow(df),7], 100, lower=FALSE)))#
    df$Collapse <- rep("No", length(df$Site))#
    df <- transform(df, Collapse = ifelse(pvalue > 0.05, "Yes", Collapse))#
    df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
    df <- as.data.frame(df)#
    df <- df[complete.cases(df),]#
    return(df)#
}#
collapse.the.dates.taxa <- function(sites, region, taxa, dates, sigma, lat, long, datemin, datemax) {#
    n.t <- rep(100, length(sites))#
    df.1 <- data.frame(sites, region, dates, sigma, lat, long, taxa)#
    colnames(df.1) <- c("Site", "Region", "X14C.year", "Sigma", "Lat", "Long", "Taxa")#
    df <- subset(df.1, df.1$X14C.year < datemax & df.1$X14C.year > datemin)#
    df <- arrange(df, desc(X14C.year))#
    df <- arrange(df, desc(Site))#
    df <- arrange(df, desc(Region))#
    df$Ttest <- c(#
    (abs(df[1:(nrow(df)-1),3]-df[2:nrow(df), 3]))/((sqrt(df[2:nrow(df), 4]^2 + df[1:(nrow(df)-1),4]^2)*sqrt(1/100))), NA)#
    df$pvalue <- c((2*pt(df[1:nrow(df),8], 100, lower=FALSE)))#
    df$Collapse <- rep("No", length(df$Site))#
    df <- transform(df, Collapse = ifelse(pvalue > 0.05, "Yes", Collapse))#
    df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
    df <- as.data.frame(df)#
    df <- df[complete.cases(df),]#
    return(df)#
}#
#
site.median <- function(sites, region, dates, sigma) {#
    n.t <- rep(100, length(sites))#
    df <- data.frame(sites, region, dates, sigma)#
    colnames(df) <- c("Site", "Region", "X14C.year", "Sigma")#
    df <- arrange(df, desc(X14C.year))#
    df <- arrange(df, desc(Region))#
    df <- arrange(df, desc(Site))#
    df$Collapse <- rep("No", length(sites))#
    df <- transform(df, Collapse = ifelse(df[nrow(df)] > 0.05, "Yes", Collapse))#
    df <- df[!(df$Collapse=="Yes" & df[1:(nrow(df)-1),1]==df[2:nrow(df), 1]),]#
    df <- as.data.frame(df)#
    df <- df[complete.cases(df),]#
    return(df)#
}#
site.time <- function(sites, dates, sigma, xmin, xmax, time) {#
    df <- data.frame(sites, dates, sigma)#
    colnames(df) <- c("Site",  "X14C.year", "Sigma")#
    df <- arrange(df, desc(X14C.year))#
    df <- arrange(df, desc(Site))#
    site.frame <- aggregate(x=df$X14C.year, by=list(df$Site), FUN=mean)#
    site.vector <- site.frame$x#
    site.frame.sig <- aggregate(x=df$Sigma, by=list(df$Site), FUN=mean)#
    site.vector.sig <- site.frame.sig$x#
    samp.intcal <- rep("intcal13", length(site.vector))#
    samp.slugdens <- BchronCalibrate(site.vector, site.vector.sig, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.median <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, median))#
    medians.all <-as.vector(samp.median[,1])#
    medians <- medians.all[medians.all < xmax & medians.all > xmin]#
    median.simple <- round((medians/100000), digits=2)*100000#
    median.table <- table(median.simple)#
    median.values <- as.numeric(paste(median.table))#
    median.frame <- data.frame(t(median.values))#
    colnames(median.frame) <- names(median.table)#
    median.t <- data.frame(t(median.frame))#
    median.df <- data.frame(add_rownames(median.t, "VALUE"))#
    colnames(median.df) <- c("Millenium", "Site")#
    median.df <- median.df[with(median.df, order(as.numeric(Millenium))), ]#
    null <- rep(0, length(time))#
    null.frame <- t(data.frame(null))#
    colnames(null.frame) <- time#
    null.t <- data.frame(t(null.frame))#
    null.df <- data.frame(add_rownames(null.t, "VALUE"))#
    colnames(null.df) <- c("Millenium", "Site")#
    all.frame <- merge(null.df, median.df, all=TRUE, by="Millenium")#
    all.frame[is.na(all.frame)] <- 0#
    all.frame <- all.frame[with(all.frame, order(as.numeric(Millenium))), ]#
    the.result <- data.frame(all.frame$Millenium, all.frame$Site.y)#
    colnames(the.result) <- c("Millenium", "Sites")#
    scaled <- as.vector(apply(data.frame(the.result$Sites), 2, function(x) scale(x)))#
    scaled.mean <- mean(scaled)#
    scaled.sd <- sd(scaled)#
    the.result$z.score <- (scaled-scaled.mean)/scaled.sd#
    the.result$p.value <- pnorm(the.result$z.score, lower.tail=FALSE)#
    return(format(the.result, digits=2))#
}#
median.stack.14C <- function(dates, sigma, sites, xmin, xmax, time){#
    samp.intcal <- rep("intcal13", length(dates))#
    samp.slugdens <- BchronCalibrate(dates, sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.median <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, median))#
    medians.all <-as.vector(samp.median[,1])#
    medians <- medians.all[medians.all < xmax & medians.all > xmin]#
    median.simple <- round((medians/100000), digits=2)*100000#
    median.table <- table(median.simple)#
    median.values <- as.numeric(paste(median.table))#
    median.frame <- data.frame(t(median.values))#
    colnames(median.frame) <- names(median.table)#
    median.t <- data.frame(t(median.frame))#
    median.df <- data.frame(add_rownames(median.t, "VALUE"))#
    colnames(median.df) <- c("Millenium", "Site")#
    median.df <- median.df[with(median.df, order(as.numeric(Millenium))), ]#
    null <- rep(0, length(time))#
    null.frame <- t(data.frame(null))#
    colnames(null.frame) <- time#
    null.t <- data.frame(t(null.frame))#
    null.df <- data.frame(add_rownames(null.t, "VALUE"))#
    colnames(null.df) <- c("Millenium", "Site")#
    all.frame <- merge(null.df, median.df, all=TRUE, by="Millenium")#
    all.frame[is.na(all.frame)] <- 0#
    all.frame <- all.frame[with(all.frame, order(as.numeric(Millenium))), ]#
    the.result <- data.frame(all.frame$Millenium, all.frame$Site.y)#
    colnames(the.result) <- c("Millenium", "Sites")#
    scaled <- as.vector(apply(data.frame(the.result$Sites), 2, function(x) scale(x)))#
    scaled.mean <- mean(scaled)#
    scaled.sd <- sd(scaled)#
    the.result$z.score <- (scaled-scaled.mean)/scaled.sd#
    the.result$p.value <- pnorm(the.result$z.score, lower.tail=FALSE)#
    return(format(the.result, digits=2))#
}#
site.time.half <- function(sites, dates, sigma, xmin, xmax, time) {#
    df <- data.frame(sites, dates, sigma)#
    colnames(df) <- c("Site",  "X14C.year", "Sigma")#
    df <- arrange(df, desc(X14C.year))#
    df <- arrange(df, desc(Site))#
    site.frame <- aggregate(x=df$X14C.year, by=list(df$Site), FUN=mean)#
    site.vector <- site.frame$x#
    site.frame.sig <- aggregate(x=df$Sigma, by=list(df$Site), FUN=mean)#
    site.vector.sig <- site.frame.sig$x#
    samp.intcal <- rep("intcal13", length(site.vector))#
    samp.slugdens <- BchronCalibrate(site.vector, site.vector.sig, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.median <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, median))#
    medians.all <-as.vector(samp.median[,1])#
    medians <- medians.all[medians.all < xmax & medians.all > xmin]#
    return(medians)#
}#
median.stack.14C.half <- function(x, sigma, sites, xmin, xmax){#
    samp.intcal <- rep("intcal13", length(x))#
    samp.slugdens <- BchronCalibrate(x, sigma, samp.intcal)#
    samp.ages <- ldply(samp.slugdens, data.frame)#
    samp.median <- data.frame(tapply(samp.ages$ageGrid, samp.ages$.id, median))#
    medians.all <-as.vector(samp.median[,1])#
    medians <- medians.all[medians.all < xmax & medians.all > xmin]#
    return(medians)#
}
###GISP2 Northern Hemisphere Temperatures#
#
gisp2 <- read.csv(file="/Users/lee/Dropbox/Documents/GISP and Civilization/gisp2.csv")#
#
roman.gisp2 <- ggplot(gisp2) +#
geom_line(aes(1950-Age, Temperature..C.))+#
geom_text(aes(x=40, y=-30, label="Pax Romana"))+#
geom_text(aes(x=270, y=-30.2, label="Imperial Crisis"))+#
geom_rect(aes(NULL, NULL), xmin=-113, xmax=-101, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
geom_text(aes(x=-106, y=-32.3, label="Cimbrian War"))+#
geom_rect(aes(NULL, NULL), xmin=166, xmax=180, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
geom_text(aes(x=175, y=-32.3, label="Marcomannic War"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
geom_text(aes(x=376, y=-32.3, label="Visigothic War"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
geom_text(aes(x=550, y=-32.3, label="Migration Period"))+#
geom_line(aes(1950-Age, Temperature..C.), lwd=1.1)+#
geom_line(aes(1950-Age, Temperature..C.), colour="light blue", lwd=0.5) +#
scale_x_continuous("Year BC/AD", limits = c(-400, 800), breaks=seq(-400, 800, 100)) +#
scale_y_continuous("Temperature (C)", limits = c(-32.5, -29.5)) +#
theme_light()#
#
ggsave(roman.gisp2, file="/Users/lee/Dropbox/Documents/GISP and Civilization/GISP2.tiff", device="tiff", dpi=300, width=10.2, height=4.39, compression = "lzw")#
####Lake Holzemaar#
holzmaar <- read.csv(file="/Users/lee/Dropbox/Documents/GISP and Civilization/holzmaar2003/Data-Table 1.csv")#
holzmaar.record <- ggplot(holzmaar) +#
geom_line(aes(Year, d13C.Organic..per.mil.VPDB.))+#
#geom_text(aes(x=40, y=-27.8, label="Pax Romana"))+#
geom_rect(aes(NULL, NULL), xmin=-113, xmax=-101, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=-106, y=-35, label="Cimbrian War"))+#
geom_rect(aes(NULL, NULL), xmin=166, xmax=180, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=175, y=-35, label="Marcomannic War"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=376, y=-35, label="Visigothic War"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=550, y=-35, label="Migration Period"))+#
geom_line(aes(Year, d13C.Organic..per.mil.VPDB.), lwd=1.1)+#
geom_line(aes(Year, d13C.Organic..per.mil.VPDB.), colour="light blue", lwd=0.5) +#
#geom_text(aes(x=270, y=-30.2, label="Imperial Crisis"))+#
scale_x_continuous("Year BC/AD", limits = c(-400, 800), breaks=seq(-400, 800, 100)) +#
scale_y_continuous(expression(paste("Organic "^13*"C ( VPDB)")), limits = c(-35, -27)) +#
theme_light()#
#
ggsave(holzmaar.record, file="/Users/lee/Dropbox/Documents/GISP and Civilization/Holzmaar.tiff", device="tiff", dpi=300, width=10.2, height=4.39, compression = "lzw")#
###Buntgen#
buentgen <- read.csv(file="/Users/lee/Dropbox/Documents/GISP and Civilization/buentgen2011europe/Fig.4 Recons-Table 1.csv")#
buentgen.record <- ggplot(buentgen) +#
geom_line(aes(Year, SMA(Buentgen_etal.Science2011_JJA.temp, 10)))+#
#geom_text(aes(x=40, y=-27.8, label="Pax Romana"))+#
geom_rect(aes(NULL, NULL), xmin=-113, xmax=-101, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=-106, y=-35, label="Cimbrian War"))+#
geom_rect(aes(NULL, NULL), xmin=166, xmax=180, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=175, y=-35, label="Marcomannic War"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=376, y=-35, label="Visigothic War"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=550, y=-35, label="Migration Period"))+#
geom_line(aes(Year, SMA(Buentgen_etal.Science2011_JJA.temp, 10)), lwd=1.1)+#
geom_line(aes(Year, SMA(Buentgen_etal.Science2011_JJA.temp, 10)), colour="light blue", lwd=0.5) +#
#geom_text(aes(x=270, y=-30.2, label="Imperial Crisis"))+#
scale_x_continuous("Year BC/AD", limits = c(-400, 800), breaks=seq(-400, 800, 100)) +#
scale_y_continuous("JJA Temp", limits=c(-3.75, 2.6)) +#
theme_light()#
#
ggsave(buentgen.record, file="/Users/lee/Dropbox/Documents/GISP and Civilization/Buentgen.tiff", device="tiff", dpi=300, width=10.2, height=4.39, compression = "lzw")#
#
fennoscandinavia <- read.csv(file="/Users/lee/Dropbox/Documents/GISP and Civilization/fennoscandia2012temperature/Fusion Temp.-Table 1.csv")#
#
fennoscandinavia.record <- ggplot(fennoscandinavia) +#
geom_line(aes(YEAR, SMA(Fussion.T, 10)))+#
#geom_text(aes(x=40, y=-27.8, label="Pax Romana"))+#
geom_rect(aes(NULL, NULL), xmin=-113, xmax=-101, ymin=-35, ymax=7, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=-106, y=-1.5, label="Cimbrian War"))+#
geom_rect(aes(NULL, NULL), xmin=166, xmax=180, ymin=-35, ymax=7, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=175, y=-1.5, label="Marcomannic War"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-35, ymax=7, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=376, y=-1.5, label="Visigothic War"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-35, ymax=7, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=550, y=-1.5, label="Migration Period"))+#
geom_line(aes(YEAR, SMA(Fussion.T, 10)), lwd=1.1)+#
geom_line(aes(YEAR, SMA(Fussion.T, 10)), colour="light blue", lwd=0.5) +#
#geom_text(aes(x=270, y=-30.2, label="Imperial Crisis"))+#
scale_x_continuous("Year BC/AD", limits = c(-400, 800), breaks=seq(-400, 800, 100)) +#
scale_y_continuous("July Temperature", limits=c(-1.5, 3)) +#
theme_light()#
mccormick <- read.csv(file="/Users/lee/Dropbox/Documents/GISP and Civilization/McCormick et al 2012 Geodatabase Historical Evidence on Roman Post-Roman Climate/Climate events in written records, 86 BC-800 AD-Table 1.csv")#
nile <- subset(mccormick, mccormick$What.code=="n")#
nile.hist <- hist(nile$When.1, breaks=80)#
nile.frame <- data.frame(nile.hist$mids, nile.hist$counts)#
colnames(nile.frame) <- c("Year", "Count")#
nile.record <- ggplot(nile.frame) +#
geom_line(aes(Year, Count)) +#
#geom_text(aes(x=40, y=-27.8, label="Pax Romana"))+#
geom_rect(aes(NULL, NULL), xmin=-113, xmax=-101, ymin=-35, ymax=15, fill="grey90", alpha=0.3)+#
geom_text(aes(x=-106, y=-1.5, label="Cimbrian War"))+#
geom_rect(aes(NULL, NULL), xmin=166, xmax=180, ymin=-35, ymax=15, fill="grey90", alpha=0.3)+#
geom_text(aes(x=175, y=-1.5, label="Marcomannic War"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-35, ymax=15, fill="grey90", alpha=0.3)+#
geom_text(aes(x=376, y=-1.5, label="Visigothic War"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-35, ymax=15, fill="grey90", alpha=0.3)+#
geom_text(aes(x=550, y=-1.5, label="Migration Period"))+#
geom_line(aes(Year, Count), lwd=1.1)+#
geom_line(aes(Year, Count), colour="light blue", lwd=0.5) +#
#geom_text(aes(x=270, y=-30.2, label="Imperial Crisis"))+#
scale_x_continuous("Year BC/AD", limits = c(-400, 800), breaks=seq(-400, 800, 100)) +#
scale_y_continuous("Decadal Nile Flood", limits=c(0, 10), breaks=seq(0, 10, 2)) +#
theme_light()
ggsave(layOut(#
list(roman.gisp2, 1:50, 7:1000),#
list(holzmaar.record, 45:100, 1:1000),#
list(nile.record, 95:150, 15:1000),#
list(buentgen.record, 145:200, 15:1000),#
list(fennoscandinavia.record, 195:250, 15:1000)#
), file="/Users/lee/Dropbox/Documents/GISP and Civilization/GermanyClimProxies.tiff", device="tiff", dpi=300, width=10, height=8)
ggsave(layOut(#
list(roman.gisp2, 1:50, 7:1000),#
list(holzmaar.record, 45:100, 1:1000),#
list(nile.record, 95:150, 15:1000),#
list(buentgen.record, 145:200, 15:1000),#
list(fennoscandinavia.record, 195:250, 15:1000)#
), file="/Users/lee/Dropbox/Documents/GISP and Civilization/GermanyClimProxies.tiff", device="tiff", dpi=300, width=10, height=6)
ggsave(layOut(#
list(roman.gisp2, 1:50, 7:1000),#
list(holzmaar.record, 43:100, 1:1000),#
list(nile.record, 93:150, 15:1000),#
list(buentgen.record, 143:200, 15:1000),#
list(fennoscandinavia.record, 193:250, 15:1000)#
), file="/Users/lee/Dropbox/Documents/GISP and Civilization/GermanyClimProxies.tiff", device="tiff", dpi=300, width=10, height=8)
ggsave(layOut(#
list(roman.gisp2, 1:50, 7:1000),#
list(holzmaar.record, 40:100, 1:1000),#
list(nile.record, 90:150, 15:1000),#
list(buentgen.record, 140:200, 15:1000),#
list(fennoscandinavia.record, 190:250, 15:1000)#
), file="/Users/lee/Dropbox/Documents/GISP and Civilization/GermanyClimProxies.tiff", device="tiff", dpi=300, width=10, height=8)
holzmaar.record <- ggplot(holzmaar) +#
geom_line(aes(Year, d13C.Organic..per.mil.VPDB.))+#
#geom_text(aes(x=40, y=-27.8, label="Pax Romana"))+#
geom_rect(aes(NULL, NULL), xmin=-113, xmax=-101, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=-106, y=-35, label="Cimbrian War"))+#
geom_rect(aes(NULL, NULL), xmin=166, xmax=180, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=175, y=-35, label="Marcomannic War"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=376, y=-35, label="Visigothic War"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=550, y=-35, label="Migration Period"))+#
geom_line(aes(Year, d13C.Organic..per.mil.VPDB.), lwd=1.1)+#
geom_line(aes(Year, d13C.Organic..per.mil.VPDB.), colour="light blue", lwd=0.5) +#
#geom_text(aes(x=270, y=-30.2, label="Imperial Crisis"))+#
scale_x_continuous("Year BC/AD", limits = c(-400, 800), breaks=seq(-400, 800, 100)) +#
scale_y_continuous(expression(paste("Org. "^13*"C ( VPDB)")), limits = c(-35, -27)) +#
theme_light()
ggsave(layOut(#
list(roman.gisp2, 1:49, 7:1000),#
list(holzmaar.record, 39:100, 1:1000),#
list(nile.record, 89:150, 15:1000),#
list(buentgen.record, 139:200, 15:1000),#
list(fennoscandinavia.record, 189:250, 15:1000)#
), file="/Users/lee/Dropbox/Documents/GISP and Civilization/GermanyClimProxies.tiff", device="tiff", dpi=300, width=10, height=8)
ggsave(layOut(#
list(roman.gisp2, 1:49, 7:1000),#
list(holzmaar.record, 39:100, 1:1000),#
list(nile.record, 89:150, 15:1000),#
list(buentgen.record, 139:200, 15:1000),#
list(fennoscandinavia.record, 189:250, 15:1000)#
), file="/Users/lee/Dropbox/Documents/GISP and Civilization/GermanyClimProxies.tiff", device="tiff", dpi=300, width=10, height=7.5)
ggsave(layOut(#
list(roman.gisp2, 1:50, 7:1000),#
list(holzmaar.record, 37:100, 1:1000),#
list(nile.record, 87:150, 15:1000),#
list(buentgen.record, 137:200, 15:1000),#
list(fennoscandinavia.record, 187:250, 15:1000)#
), file="/Users/lee/Dropbox/Documents/GISP and Civilization/GermanyClimProxies.tiff", device="tiff", dpi=300, width=10, height=8)
ggsave(layOut(#
list(roman.gisp2, 1:50, 7:1000),#
list(holzmaar.record, 38:100, 1:1000),#
list(nile.record, 88:150, 15:1000),#
list(buentgen.record, 138:200, 15:1000),#
list(fennoscandinavia.record, 188:250, 15:1000)#
), file="/Users/lee/Dropbox/Documents/GISP and Civilization/GermanyClimProxies.tiff", device="tiff", dpi=300, width=10, height=8)
buentgen.record <- ggplot(buentgen) +#
geom_line(aes(Year, SMA(Buentgen_etal.Science2011_JJA.temp, 10)))+#
#geom_text(aes(x=40, y=-27.8, label="Pax Romana"))+#
geom_rect(aes(NULL, NULL), xmin=-113, xmax=-101, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=-106, y=-35, label="Cimbrian War"))+#
geom_rect(aes(NULL, NULL), xmin=166, xmax=180, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=175, y=-35, label="Marcomannic War"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=376, y=-35, label="Visigothic War"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=550, y=-35, label="Migration Period"))+#
geom_line(aes(Year, SMA(Buentgen_etal.Science2011_JJA.temp, 10)), lwd=1.1)+#
geom_line(aes(Year, SMA(Buentgen_etal.Science2011_JJA.temp, 10)), colour="light blue", lwd=0.5) +#
#geom_text(aes(x=270, y=-30.2, label="Imperial Crisis"))+#
scale_x_continuous("Year BC/AD", limits = c(-400, 800), breaks=seq(-400, 800, 100)) +#
scale_y_continuous("JJA Temp", limits=c(-3.75, 2.6), beaks=seq(-2, 2, 2)) +#
theme_light()
buentgen.record <- ggplot(buentgen) +#
geom_line(aes(Year, SMA(Buentgen_etal.Science2011_JJA.temp, 10)))+#
#geom_text(aes(x=40, y=-27.8, label="Pax Romana"))+#
geom_rect(aes(NULL, NULL), xmin=-113, xmax=-101, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=-106, y=-35, label="Cimbrian War"))+#
geom_rect(aes(NULL, NULL), xmin=166, xmax=180, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=175, y=-35, label="Marcomannic War"))+#
geom_rect(aes(NULL, NULL), xmin=376, xmax=410, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=376, y=-35, label="Visigothic War"))+#
geom_rect(aes(NULL, NULL), xmin=500, xmax=600, ymin=-35, ymax=2.8, fill="grey90", alpha=0.3)+#
#geom_text(aes(x=550, y=-35, label="Migration Period"))+#
geom_line(aes(Year, SMA(Buentgen_etal.Science2011_JJA.temp, 10)), lwd=1.1)+#
geom_line(aes(Year, SMA(Buentgen_etal.Science2011_JJA.temp, 10)), colour="light blue", lwd=0.5) +#
#geom_text(aes(x=270, y=-30.2, label="Imperial Crisis"))+#
scale_x_continuous("Year BC/AD", limits = c(-400, 800), breaks=seq(-400, 800, 100)) +#
scale_y_continuous("JJA Temp", limits=c(-3.75, 2.6), breaks=seq(-2, 2, 2)) +#
theme_light()
ggsave(layOut(#
list(roman.gisp2, 1:50, 7:1000),#
list(holzmaar.record, 38:100, 1:1000),#
list(nile.record, 88:150, 15:1000),#
list(buentgen.record, 138:200, 15:1000),#
list(fennoscandinavia.record, 188:250, 15:1000)#
), file="/Users/lee/Dropbox/Documents/GISP and Civilization/GermanyClimProxies.tiff", device="tiff", dpi=300, width=10, height=8)
library(shiny)
runApp("~/Desktop/xrf-app")
runApp("~/Desktop/xrf-app")
runApp("~/Desktop/xrf-app")
runApp("~/Desktop/xrf-app")
runApp()
runApp("~/Desktop/5i Results App")
no_col <- max(count.fields(file="~/Desktop/Results.csv", sep=","))
data.frame.first <- read.table("~/Desktop/Results.csv", sep=",", fill=TRUE, col.names=1:no_col, comment.char = "")
names <- c("File", "DateTime", "Operator", "Name", "ID", "Field1", "Field2", "Application", "Method", "ElapsedTime", "Alloy 1", "Match Qual 1", "Alloy 2", "Match Qual 2", "Alloy 3", "Match Qual 3", "Cal Check")
n <- length(data.frame.first[1,])
data.frame <- as.data.frame(data.frame.first[2:n,])#
    colnames(data.frame) <- names#
    data.frame$Date <- substr(data.frame$DateTime, 1, 10)
head(data.frame)
metadata.dat <- data.frame
dates <- unique(metadata.dat$DateTime)
dates
dates <- substr(dates, 1, 10)
dates <- subset(dates, !dates=="")
dates <- as.Date(dates, format="%m-%d-%Y")
date.values <- max(as.Date(dates))
date.values
dates <- unique(metadata.dat$DateTime)
head(dates)
dates <- substr(dates, 1, 10)
head(dates)
dates <- subset(dates, !(dates=="DateTime"))
dates
dates <- subset(dates, !dates=="")
dates
dates <- as.Date(dates, format="%m-%d-%Y")
dates
date.values <- max(as.Date(dates))
date.values
runApp("~/Desktop/5i Results App")
runApp("~/Desktop/5i Results App")
dates <- unique(metadata.dat$DateTime)
dates <- substr(dates, 1, 10)
dates <- subset(dates, !(dates=="DateTime"))
dates <- subset(dates, !dates=="")
dates <- as.vector(as.Date(dates, format="%m-%d-%Y"))
head(dates)
dates <- substr(dates, 1, 10)#
    dates <- subset(dates, !(dates=="DateTime"))#
    dates <- subset(dates, !dates=="")
dates
dates <- unique(metadata.dat$DateTime)#
    dates <- substr(dates, 1, 10)#
    dates <- subset(dates, !(dates=="DateTime"))#
    dates <- subset(dates, !dates=="")
dates
dates <- as.Date(dates, format="%m-%d-%Y")
dates
date.values <- max(as.Date(dates))
date.values
dates <- unique(metadata.dat$DateTime)#
    dates <- substr(dates, 1, 10)#
    dates <- subset(dates, !(dates=="DateTime"))#
    dates <- subset(dates, !dates=="")#
    dates <- as.vector(as.Date(dates, format="%m-%d-%Y"))#
    date.values <- min(as.Date(dates))#
    date.values
runApp("~/Desktop/5i Results App")
runApp("~/Desktop/5i Results App")
runApp("~/Desktop/5i Results App")
runApp("~/Desktop/5i Results App")
runApp("~/Desktop/5i Results App")
runApp("~/Desktop/5i Results App")
runApp("~/Desktop/5i Results App")
runApp("~/Desktop/5i Results App")
runApp("~/Desktop/5i Results App")
runApp("~/Desktop/5i Results App")
runApp("~/Desktop/5i Results App")
runApp("~/Desktop/5i Results App")
runApp("~/Desktop/5i Results App")
runApp("~/Desktop/5i Results App")
runApp("~/Desktop/5i Results App")
runApp("~/Desktop/5i Results App")
runApp("~/Desktop/5i Results App")
runApp("~/Desktop/xrf-app")
